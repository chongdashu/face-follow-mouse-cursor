# Select additional open source profiles
_Exported on 11/6/2025 at 22:26:53 GMT from Cursor (2.0.63)_

---

**User**

@node (1044-1046) We have @aioriented-profile.png 

Pick another 2-3 from some well known open source source

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

**Cursor**


Reviewing the current implementation to understand how to integrate the additional portrait images.



Gathering 2-3 freely usable portrait images from reputable sources. Checking the Upload CSS to understand the current styling:



Selecting 2-3 Unsplash portrait images with direct URLs. Creating a curated list and updating the Upload component to show a grid of example images.



Creating a curated list of portrait images. Using Unsplash direct URLs with specific photo IDs for reliable hotlinking:


```typescript
/**
 * Curated list of example portrait images for the upload component
 * Includes local image and open-source portraits from Unsplash
 */

export interface ExamplePortrait {
  /** Display name for the portrait */
  name: string
  /** Image URL (local path or external URL) */
  url: string
  /** Photographer/attribution name */
  photographer?: string
  /** Source platform */
  source: 'local' | 'unsplash' | 'pexels'
  /** License information */
  license: string
  /** Link to original source (optional) */
  sourceUrl?: string
}

/**
 * List of example portraits available for quick selection
 * All images are free to use and allow hotlinking
 */
export const EXAMPLE_PORTRAITS: ExamplePortrait[] = [
  {
    name: 'AI Oriented Profile',
    url: '/aioriented-profile.png',
    source: 'local',
    license: 'Local image'
  },
  {
    name: 'Portrait by Joseph Gonzalez',
    url: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800&q=80&fit=crop',
    photographer: 'Joseph Gonzalez',
    source: 'unsplash',
    license: 'Unsplash License (free to use)',
    sourceUrl: 'https://unsplash.com/photos/iFgRcqHznqg'
  },
  {
    name: 'Portrait by Lianhao Qu',
    url: 'https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=800&q=80&fit=crop',
    photographer: 'Lianhao Qu',
    source: 'unsplash',
    license: 'Unsplash License (free to use)',
    sourceUrl: 'https://unsplash.com/photos/dSh4HD3fXbs'
  },
  {
    name: 'Portrait by Matheus Ferrero',
    url: 'https://images.unsplash.com/photo-1534528741775-53994a69daeb?w=800&q=80&fit=crop',
    photographer: 'Matheus Ferrero',
    source: 'unsplash',
    license: 'Unsplash License (free to use)',
    sourceUrl: 'https://unsplash.com/photos/uJ8LNVCBjFQ'
  }
]

```


Updating the Upload component to show a grid of example images:



Updating the Upload component to use the example portraits grid:


```typescriptreact
import { useRef, useState } from 'react'
import { CONFIG } from '../config'
import { EXAMPLE_PORTRAITS } from '../lib/examplePortraits'
import './Upload.css'

interface UploadProps {
  onImageUpload: (image: HTMLImageElement) => void
}

/**
 * Upload component with drag-and-drop support
 * Resizes images to max width specified in config
 */
export default function Upload({ onImageUpload }: UploadProps) {
  const [isDragging, setIsDragging] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  /**
   * Resize image to max width while maintaining aspect ratio
   */
  const resizeImage = (file: File): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = (e) => {
        const img = new Image()
        img.onload = () => {
          const canvas = document.createElement('canvas')
          const ctx = canvas.getContext('2d')
          if (!ctx) {
            reject(new Error('Could not get canvas context'))
            return
          }

          let { width, height } = img
          if (width > CONFIG.maxImageWidth) {
            height = (height * CONFIG.maxImageWidth) / width
            width = CONFIG.maxImageWidth
          }

          canvas.width = width
          canvas.height = height
          ctx.drawImage(img, 0, 0, width, height)

          const resizedImg = new Image()
          resizedImg.onload = () => resolve(resizedImg)
          resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
          resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
        }
        img.onerror = () => reject(new Error('Failed to load image'))
        img.src = e.target?.result as string
      }
      reader.onerror = () => reject(new Error('Failed to read file'))
      reader.readAsDataURL(file)
    })
  }

  const handleFile = async (file: File) => {
    if (!file.type.startsWith('image/')) {
      alert('Please upload an image file')
      return
    }

    try {
      const image = await resizeImage(file)
      onImageUpload(image)
    } catch (error) {
      console.error('Error processing image:', error)
      alert('Failed to process image. Please try again.')
    }
  }

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)

    const file = e.dataTransfer.files[0]
    if (file) {
      handleFile(file)
    }
  }

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(true)
  }

  const handleDragLeave = () => {
    setIsDragging(false)
  }

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      handleFile(file)
    }
  }

  /**
   * Load and use the default profile image
   */
  const handleQuickLoad = async () => {
    try {
      const img = new Image()
      img.crossOrigin = 'anonymous'
      
      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve()
        img.onerror = () => reject(new Error('Failed to load default image'))
        img.src = '/aioriented-profile.png'
      })

      // Apply same resizing logic as file upload
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      if (!ctx) {
        throw new Error('Could not get canvas context')
      }

      let { width, height } = img
      if (width > CONFIG.maxImageWidth) {
        height = (height * CONFIG.maxImageWidth) / width
        width = CONFIG.maxImageWidth
      }

      canvas.width = width
      canvas.height = height
      ctx.drawImage(img, 0, 0, width, height)

      const resizedImg = new Image()
      await new Promise<void>((resolve, reject) => {
        resizedImg.onload = () => resolve()
        resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
        resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
      })

      onImageUpload(resizedImg)
    } catch (error) {
      console.error('Error loading default image:', error)
      alert('Failed to load default image. Please try again.')
    }
  }

  return (
    <div className="upload-container">
      <div
        className={`upload-dropzone ${isDragging ? 'dragging' : ''}`}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onClick={() => fileInputRef.current?.click()}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept="image/jpeg,image/png,image/webp"
          onChange={handleFileInput}
          style={{ display: 'none' }}
        />
        <div className="upload-content">
          <svg
            width="64"
            height="64"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <polyline points="17 8 12 3 7 8" />
            <line x1="12" y1="3" x2="12" y2="15" />
          </svg>
          <h2>Upload a Portrait</h2>
          <p>Drag and drop an image here, or click to select</p>
          <p className="upload-hint">Supports JPG, PNG, and WebP (max {CONFIG.maxImageWidth}px width)</p>
        </div>
      </div>
      <button className="quick-load-button" onClick={(e) => { e.stopPropagation(); handleQuickLoad(); }}>
        <span className="quick-load-icon">✨</span>
        <span>Try Example Image</span>
      </button>
    </div>
  )
}


```

```typescriptreact
import { useRef, useState } from 'react'
import { CONFIG } from '../config'
import { EXAMPLE_PORTRAITS } from '../lib/examplePortraits'
import './Upload.css'

interface UploadProps {
  onImageUpload: (image: HTMLImageElement) => void
}

/**
 * Upload component with drag-and-drop support
 * Resizes images to max width specified in config
 */
export default function Upload({ onImageUpload }: UploadProps) {
  const [isDragging, setIsDragging] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  /**
   * Resize image to max width while maintaining aspect ratio
   */
  const resizeImage = (file: File): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = (e) => {
        const img = new Image()
        img.onload = () => {
          const canvas = document.createElement('canvas')
          const ctx = canvas.getContext('2d')
          if (!ctx) {
            reject(new Error('Could not get canvas context'))
            return
          }

          let { width, height } = img
          if (width > CONFIG.maxImageWidth) {
            height = (height * CONFIG.maxImageWidth) / width
            width = CONFIG.maxImageWidth
          }

          canvas.width = width
          canvas.height = height
          ctx.drawImage(img, 0, 0, width, height)

          const resizedImg = new Image()
          resizedImg.onload = () => resolve(resizedImg)
          resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
          resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
        }
        img.onerror = () => reject(new Error('Failed to load image'))
        img.src = e.target?.result as string
      }
      reader.onerror = () => reject(new Error('Failed to read file'))
      reader.readAsDataURL(file)
    })
  }

  const handleFile = async (file: File) => {
    if (!file.type.startsWith('image/')) {
      alert('Please upload an image file')
      return
    }

    try {
      const image = await resizeImage(file)
      onImageUpload(image)
    } catch (error) {
      console.error('Error processing image:', error)
      alert('Failed to process image. Please try again.')
    }
  }

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)

    const file = e.dataTransfer.files[0]
    if (file) {
      handleFile(file)
    }
  }

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(true)
  }

  const handleDragLeave = () => {
    setIsDragging(false)
  }

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      handleFile(file)
    }
  }

  /**
   * Load and use an example portrait image from URL
   * Applies same resizing logic as file upload
   */
  const handleExampleLoad = async (imageUrl: string) => {
    try {
      const img = new Image()
      img.crossOrigin = 'anonymous'
      
      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve()
        img.onerror = () => reject(new Error('Failed to load example image'))
        img.src = imageUrl
      })

      // Apply same resizing logic as file upload
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      if (!ctx) {
        throw new Error('Could not get canvas context')
      }

      let { width, height } = img
      if (width > CONFIG.maxImageWidth) {
        height = (height * CONFIG.maxImageWidth) / width
        width = CONFIG.maxImageWidth
      }

      canvas.width = width
      canvas.height = height
      ctx.drawImage(img, 0, 0, width, height)

      const resizedImg = new Image()
      await new Promise<void>((resolve, reject) => {
        resizedImg.onload = () => resolve()
        resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
        resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
      })

      onImageUpload(resizedImg)
    } catch (error) {
      console.error('Error loading example image:', error)
      alert('Failed to load example image. Please try again.')
    }
  }

  return (
    <div className="upload-container">
      <div
        className={`upload-dropzone ${isDragging ? 'dragging' : ''}`}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onClick={() => fileInputRef.current?.click()}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept="image/jpeg,image/png,image/webp"
          onChange={handleFileInput}
          style={{ display: 'none' }}
        />
        <div className="upload-content">
          <svg
            width="64"
            height="64"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <polyline points="17 8 12 3 7 8" />
            <line x1="12" y1="3" x2="12" y2="15" />
          </svg>
          <h2>Upload a Portrait</h2>
          <p>Drag and drop an image here, or click to select</p>
          <p className="upload-hint">Supports JPG, PNG, and WebP (max {CONFIG.maxImageWidth}px width)</p>
        </div>
      </div>
      <button className="quick-load-button" onClick={(e) => { e.stopPropagation(); handleQuickLoad(); }}>
        <span className="quick-load-icon">✨</span>
        <span>Try Example Image</span>
      </button>
    </div>
  )
}


```

```typescriptreact
import { useRef, useState } from 'react'
import { CONFIG } from '../config'
import { EXAMPLE_PORTRAITS } from '../lib/examplePortraits'
import './Upload.css'

interface UploadProps {
  onImageUpload: (image: HTMLImageElement) => void
}

/**
 * Upload component with drag-and-drop support
 * Resizes images to max width specified in config
 */
export default function Upload({ onImageUpload }: UploadProps) {
  const [isDragging, setIsDragging] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  /**
   * Resize image to max width while maintaining aspect ratio
   */
  const resizeImage = (file: File): Promise<HTMLImageElement> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = (e) => {
        const img = new Image()
        img.onload = () => {
          const canvas = document.createElement('canvas')
          const ctx = canvas.getContext('2d')
          if (!ctx) {
            reject(new Error('Could not get canvas context'))
            return
          }

          let { width, height } = img
          if (width > CONFIG.maxImageWidth) {
            height = (height * CONFIG.maxImageWidth) / width
            width = CONFIG.maxImageWidth
          }

          canvas.width = width
          canvas.height = height
          ctx.drawImage(img, 0, 0, width, height)

          const resizedImg = new Image()
          resizedImg.onload = () => resolve(resizedImg)
          resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
          resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
        }
        img.onerror = () => reject(new Error('Failed to load image'))
        img.src = e.target?.result as string
      }
      reader.onerror = () => reject(new Error('Failed to read file'))
      reader.readAsDataURL(file)
    })
  }

  const handleFile = async (file: File) => {
    if (!file.type.startsWith('image/')) {
      alert('Please upload an image file')
      return
    }

    try {
      const image = await resizeImage(file)
      onImageUpload(image)
    } catch (error) {
      console.error('Error processing image:', error)
      alert('Failed to process image. Please try again.')
    }
  }

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(false)

    const file = e.dataTransfer.files[0]
    if (file) {
      handleFile(file)
    }
  }

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragging(true)
  }

  const handleDragLeave = () => {
    setIsDragging(false)
  }

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      handleFile(file)
    }
  }

  /**
   * Load and use an example portrait image from URL
   * Applies same resizing logic as file upload
   */
  const handleExampleLoad = async (imageUrl: string) => {
    try {
      const img = new Image()
      img.crossOrigin = 'anonymous'
      
      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve()
        img.onerror = () => reject(new Error('Failed to load example image'))
        img.src = imageUrl
      })

      // Apply same resizing logic as file upload
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')
      if (!ctx) {
        throw new Error('Could not get canvas context')
      }

      let { width, height } = img
      if (width > CONFIG.maxImageWidth) {
        height = (height * CONFIG.maxImageWidth) / width
        width = CONFIG.maxImageWidth
      }

      canvas.width = width
      canvas.height = height
      ctx.drawImage(img, 0, 0, width, height)

      const resizedImg = new Image()
      await new Promise<void>((resolve, reject) => {
        resizedImg.onload = () => resolve()
        resizedImg.onerror = () => reject(new Error('Failed to create resized image'))
        resizedImg.src = canvas.toDataURL('image/jpeg', 0.9)
      })

      onImageUpload(resizedImg)
    } catch (error) {
      console.error('Error loading example image:', error)
      alert('Failed to load example image. Please try again.')
    }
  }

  return (
    <div className="upload-container">
      <div
        className={`upload-dropzone ${isDragging ? 'dragging' : ''}`}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onClick={() => fileInputRef.current?.click()}
      >
        <input
          ref={fileInputRef}
          type="file"
          accept="image/jpeg,image/png,image/webp"
          onChange={handleFileInput}
          style={{ display: 'none' }}
        />
        <div className="upload-content">
          <svg
            width="64"
            height="64"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <polyline points="17 8 12 3 7 8" />
            <line x1="12" y1="3" x2="12" y2="15" />
          </svg>
          <h2>Upload a Portrait</h2>
          <p>Drag and drop an image here, or click to select</p>
          <p className="upload-hint">Supports JPG, PNG, and WebP (max {CONFIG.maxImageWidth}px width)</p>
        </div>
      </div>
      <div className="example-portraits-section">
        <p className="example-portraits-callout">Or try one of these images...</p>
        <div className="example-portraits-grid">
          {EXAMPLE_PORTRAITS.map((portrait, index) => (
            <button
              key={index}
              className="example-portrait-card"
              onClick={(e) => {
                e.stopPropagation()
                handleExampleLoad(portrait.url)
              }}
              title={portrait.photographer ? `Photo by ${portrait.photographer}` : portrait.name}
            >
              <img
                src={portrait.url}
                alt={portrait.name}
                className="example-portrait-image"
                crossOrigin="anonymous"
              />
              <div className="example-portrait-overlay">
                <span className="example-portrait-name">{portrait.name}</span>
              </div>
            </button>
          ))}
        </div>
      </div>
    </div>
  )
}


```


Adding CSS styles for the example portraits grid:


```css
.upload-container {
  width: 100%;
  max-width: 600px;
  padding: 2rem;
}

.upload-dropzone {
  border: 2px dashed rgba(255, 255, 255, 0.3);
  border-radius: 12px;
  padding: 4rem 2rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s ease;
  background: rgba(255, 255, 255, 0.05);
}

.upload-dropzone:hover {
  border-color: rgba(255, 255, 255, 0.5);
  background: rgba(255, 255, 255, 0.08);
}

.upload-dropzone.dragging {
  border-color: rgba(100, 150, 255, 0.8);
  background: rgba(100, 150, 255, 0.1);
}

.upload-content svg {
  margin-bottom: 1rem;
  opacity: 0.7;
}

.upload-content h2 {
  margin: 0.5rem 0;
  font-size: 1.5rem;
}

.upload-content p {
  margin: 0.5rem 0;
  opacity: 0.7;
}

.upload-hint {
  font-size: 0.875rem;
  opacity: 0.5;
}

.example-portraits-section {
  margin-top: 2rem;
}

.example-portraits-callout {
  text-align: center;
  margin: 0 0 1rem 0;
  font-size: 0.95rem;
  opacity: 0.8;
  color: white;
}

.example-portraits-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 1rem;
  margin-top: 1rem;
}

.example-portrait-card {
  position: relative;
  aspect-ratio: 1;
  border: 2px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  overflow: hidden;
  cursor: pointer;
  background: rgba(255, 255, 255, 0.05);
  padding: 0;
  transition: all 0.3s ease;
}

.example-portrait-card:hover {
  border-color: rgba(255, 255, 255, 0.5);
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}

.example-portrait-card:active {
  transform: translateY(-2px);
}

.example-portrait-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.example-portrait-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
  padding: 0.75rem 0.5rem 0.5rem;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.example-portrait-card:hover .example-portrait-overlay {
  opacity: 1;
}

.example-portrait-name {
  font-size: 0.75rem;
  color: white;
  font-weight: 500;
  display: block;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


```


Marking the final todo as completed:



## Summary

1. Created `src/lib/examplePortraits.ts` with 4 example portraits:
   - Local: `aioriented-profile.png`
   - 3 Unsplash portraits with direct URLs, photographer credits, and license info

2. Updated `Upload.tsx`:
   - Replaced the single "Try Example Image" button with a callout "Or try one of these images..."
   - Added a grid showing all example portraits
   - Each portrait card is clickable and loads the selected image

3. Updated `Upload.css`:
   - Added styles for the example portraits section
   - Grid layout with hover effects
   - Cards show image names on hover

The Unsplash images include:
- Direct URLs that support hotlinking
- Photographer attribution
- License information (Unsplash License - free to use)
- Source URLs for reference

The grid displays all 4 portraits in a responsive layout. Clicking any card loads that image using the same resizing logic as file uploads.

---

**User**

When it is loading and generating depth map, it should overlay the image selection / drop box - rather than appear below

---

**Cursor**


Checking how the loading/processing state is handled to overlay the upload component during depth map generation.



Updating App.tsx to overlay the Upload component on top of the Viewer during depth map generation:


```typescriptreact
import { useState } from 'react'
import Upload from './components/Upload'
import Viewer from './components/Viewer'
import AtlasGenerator from './components/AtlasGenerator'
import './App.css'

/**
 * Main app component that handles the upload → viewer flow
 * Supports both depth-based parallax and optional atlas mode
 */
function App() {
  const [portraitImage, setPortraitImage] = useState<HTMLImageElement | null>(null)
  const [depthMap, setDepthMap] = useState<ImageData | null>(null)
  const [isProcessing, setIsProcessing] = useState(false)

  // Atlas mode state
  const [generatedAtlas, setGeneratedAtlas] = useState<Map<string, string> | null>(null)
  const [showAtlasGenerator, setShowAtlasGenerator] = useState(false)
  const [atlasError, setAtlasError] = useState<string | null>(null)

  const handleImageUpload = async (image: HTMLImageElement) => {
    setPortraitImage(image)
    setIsProcessing(true)
    setDepthMap(null)
    setGeneratedAtlas(null) // Reset atlas when new image uploaded
    setAtlasError(null)

    // Depth processing will be handled by Viewer component
  }

  const handleDepthReady = (depth: ImageData) => {
    setDepthMap(depth)
    setIsProcessing(false)
  }

  const handleGenerateAtlas = () => {
    setShowAtlasGenerator(true)
    setAtlasError(null)
  }

  const handleAtlasGenerated = (imageMap: Map<string, string>) => {
    setGeneratedAtlas(imageMap)
    setShowAtlasGenerator(false)
    setAtlasError(null)
  }

  const handleCancelGeneration = () => {
    setShowAtlasGenerator(false)
  }

  const handleResetAtlas = () => {
    setGeneratedAtlas(null)
    setAtlasError(null)
  }

  // Show viewer when both portrait and depth are ready
  if (portraitImage && depthMap) {
    return (
      <div className="app">
        <Viewer
          portraitImage={portraitImage}
          depthMap={depthMap}
          generatedAtlas={generatedAtlas}
          atlasError={atlasError}
          onGenerateAtlas={handleGenerateAtlas}
          onResetAtlas={handleResetAtlas}
          onReset={() => {
            setPortraitImage(null)
            setDepthMap(null)
            setGeneratedAtlas(null)
            setShowAtlasGenerator(false)
            setAtlasError(null)
            setIsProcessing(false)
          }}
        />

        {/* Show generator modal when triggered */}
        {showAtlasGenerator && portraitImage && (
          <div className="atlas-generator-overlay">
            <div className="atlas-generator-container">
              <AtlasGenerator
                portraitImage={portraitImage}
                onAtlasGenerated={handleAtlasGenerated}
                onCancel={handleCancelGeneration}
              />
            </div>
          </div>
        )}
      </div>
    )
  }

  // Show upload and processing
  return (
    <div className="app">
      {/* Show Viewer in background when processing */}
      {isProcessing && portraitImage && (
        <Viewer
          portraitImage={portraitImage}
          depthMap={null}
          onDepthReady={handleDepthReady}
          onReset={() => {
            setPortraitImage(null)
            setDepthMap(null)
            setGeneratedAtlas(null)
            setShowAtlasGenerator(false)
            setAtlasError(null)
            setIsProcessing(false)
          }}
        />
      )}

      {/* Overlay Upload component when processing */}
      <div className={isProcessing && portraitImage ? 'upload-overlay' : ''}>
        <Upload onImageUpload={handleImageUpload} />
      </div>

      {/* Show generator modal when triggered */}
      {showAtlasGenerator && portraitImage && (
        <div className="atlas-generator-overlay">
          <div className="atlas-generator-container">
            <AtlasGenerator
              portraitImage={portraitImage}
              onAtlasGenerated={handleAtlasGenerated}
              onCancel={handleCancelGeneration}
            />
          </div>
        </div>
      )}
    </div>
  )
}

export default App


```


Adding CSS for the upload overlay:


```css
.app {
  width: 100%;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
}

/* Upload Overlay - shown when processing depth map */
.upload-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
}

/* Atlas Generator Overlay */
.atlas-generator-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  backdrop-filter: blur(2px);
}

.atlas-generator-container {
  background: white;
  border-radius: 12px;
  padding: 32px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
}


```


Updated the code so the Upload component overlays the Viewer during depth map generation.

1. **Modified `App.tsx`**: When `isProcessing` is true, the Viewer renders first (background), and the Upload component is wrapped in an overlay div.

2. **Added CSS in `App.css`**: Created `.upload-overlay` that:
   - Uses `position: fixed` to cover the entire viewport
   - Has a semi-transparent dark background (`rgba(0, 0, 0, 0.5)`)
   - Uses `backdrop-filter: blur(4px)` for a blur effect
   - Centers the Upload component
   - Uses `z-index: 100` (above the Viewer but below the Atlas Generator modal)

When an image is uploaded and the depth map is generating, the Upload component appears as an overlay on top of the Viewer (which shows the processing spinner in the background), instead of appearing below it.

The Viewer's processing overlay ("Generating depth map...") remains visible behind the Upload overlay, providing visual feedback that processing is happening.

---

**User**

It should appear on top of the 'Upload a portrait' - right now the modal is behind.

---

**Cursor**


Increasing the processing overlay's z-index so it appears above the Upload component:



Updating the processing overlay to use `position: fixed` and a higher z-index so it appears above the Upload component:


```css
.viewer-container {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow: hidden;
}

.viewer-canvas {
  width: 100%;
  height: 100%;
  cursor: auto;
}

.viewer-canvas.cursor-hidden {
  cursor: none;
}

.processing-overlay,
.error-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.8);
  z-index: 150;
}

.error-banner {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(255, 100, 100, 0.9);
  color: white;
  padding: 0.75rem 1rem;
  border-radius: 8px;
  font-size: 0.875rem;
  z-index: 100;
  max-width: 300px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.error-banner p {
  margin: 0;
}

.processing-overlay p,
.error-overlay p {
  margin: 0.5rem 0;
  color: white;
}

.processing-hint,
.error-hint {
  font-size: 0.875rem;
  opacity: 0.7;
}

.spinner {
  width: 48px;
  height: 48px;
  border: 4px solid rgba(255, 255, 255, 0.2);
  border-top-color: white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}


```


Updated the processing overlay to appear above the Upload component:

1. Changed `position: absolute` to `position: fixed` so it's positioned relative to the viewport, not the viewer container
2. Increased `z-index` from `10` to `150` (higher than the upload-overlay's `z-index: 100`)

When the depth map is generating, the "Generating depth map..." processing overlay appears on top of the Upload component, not behind it.

---

**User**

The model is stored in public, but because i have .gitignored it, when i deploy on vercel, it can't find it.

How can i store it? is there a vercel storage I can use?

---

**Cursor**


Checking how the model is loaded and what's in `.gitignore`:



Checking the Vercel configuration and model loading code:



The model is gitignored, so it won't deploy. Options:

- Vercel Blob Storage (recommended): store the model in Vercel Blob and serve it via an API route.
- External CDN: host on Hugging Face or Cloudflare R2 and download on-demand.

Implementing Vercel Blob Storage:



Providing two options. Option 1: External CDN (simplest) — use Hugging Face since the model is already there:



Implementing both options. Option 1: CDN (simplest) — use Hugging Face CDN:



Adding model URL configuration and updating the code to support both local and CDN sources:


```typescript
/**
 * Configuration constants for the face-follow cursor demo
 */

export const CONFIG = {
  // Angle clamps (degrees)
  yawRange: 12,
  pitchRange: 8,

  // Smoothing
  emaAlpha: 0.2,
  emaAlphaMin: 0.1,
  emaAlphaMax: 0.35,

  // Dead zone (percentage of min viewport dimension)
  deadZone: 0.08,

  // Depth scale (near-to-far displacement as percentage of plane size)
  depthScale: 0.015, // 1.5%
  depthScaleMin: 0.01,
  depthScaleMax: 0.025,

  // Mesh subdivisions
  meshSubdivisions: 128,
  meshSubdivisionsFallback: 64,

  // Texture sizes
  textureSize: 1024,
  textureSizeFallback: 768,

  // Image processing
  maxImageWidth: 1024,

  // Performance thresholds
  targetFPS: 60,
  frameTimeThreshold: 16.7, // ms

  // Debug: skip model loading and use fallback immediately
  // Set to true to test without ONNX model
  useFallbackOnly: false,

  // Model path configuration
  // For local development: '/models/depth-anything-v2-small.onnx'
  // For production (CDN): Use Hugging Face CDN URL or Vercel Blob URL
  // Leave empty to try local first, then fallback to CDN
  modelPath: '', // Empty = auto-detect (local first, then CDN)
  
  // CDN fallback URL (used if local model not found)
  // Hugging Face CDN URLs for Depth Anything V2 models:
  // - Small (recommended for web): https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx
  // - Large q4f16 (235MB, best balance): https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx
  // - Large fp16 (669MB, high quality): https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx
  modelCdnUrl: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx',
} as const;

/**
 * Atlas mode configuration (for dynamic gaze image generation)
 */
export const ATLAS_CONFIG = {
  // Grid parameters for gaze generation
  min: -15,
  max: 15,
  step: 3,
  size: 1024,

  // Fallback image when specific grid position not found
  fallbackImage: 'px0_py0',

  // Cursor debounce for image swapping (ms)
  debounceMs: 16,

  // Preload radius (how many neighbors to preload)
  preloadRadius: 1,
} as const;


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Creating Option 2: Vercel Blob Storage API route. Adding an API route to serve the model from Vercel Blob:


```typescript
/**
 * Vercel Serverless Function to serve the depth model from Vercel Blob Storage
 *
 * This endpoint streams the model file from Vercel Blob Storage, allowing
 * you to store large model files without committing them to git.
 *
 * Usage:
 * GET /api/model
 *
 * Environment Variables Required:
 * - BLOB_READ_WRITE_TOKEN: Vercel Blob Storage token (get from Vercel dashboard)
 *
 * Setup:
 * 1. Install @vercel/blob: npm install @vercel/blob
 * 2. Upload your model to Vercel Blob Storage (see instructions below)
 * 3. Set BLOB_READ_WRITE_TOKEN in Vercel environment variables
 * 4. Update config.ts to use: modelPath: '/api/model'
 */

import { getBlob } from '@vercel/blob'

interface VercelRequest {
  method?: string
}

interface VercelResponse {
  status: (code: number) => VercelResponse
  setHeader: (name: string, value: string) => VercelResponse
  send: (data: any) => void
  json: (data: any) => void
}

export default async function handler(
  req: VercelRequest,
  res: VercelResponse
) {
  // Only allow GET requests
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  try {
    // Get blob token from environment
    const blobToken = process.env.BLOB_READ_WRITE_TOKEN
    if (!blobToken) {
      return res.status(500).json({
        error: 'BLOB_READ_WRITE_TOKEN not configured. Please set it in your Vercel environment variables.'
      })
    }

    // The blob key/name - update this to match your uploaded file name
    const blobKey = 'depth-anything-v2-small.onnx'

    // Fetch the blob
    const blob = await getBlob(blobKey, {
      token: blobToken
    })

    // Set appropriate headers for ONNX file
    res.setHeader('Content-Type', 'application/octet-stream')
    res.setHeader('Content-Disposition', `attachment; filename="${blobKey}"`)
    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')

    // Stream the blob data
    return res.send(blob)
  } catch (error: any) {
    console.error('[MODEL-API] Error serving model:', error)
    return res.status(500).json({
      error: error.message || 'Failed to serve model file'
    })
  }
}

```


Adding the Vercel Blob dependency and creating a setup guide:


```json
{
  "name": "face-follow-mouse-cursor",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0"
  },
  "dependencies": {
    "@vercel/blob": "^0.26.0",
    "@vercel/kv": "^2.0.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "three": "^0.169.0",
    "onnxruntime-web": "^1.19.2"
  },
  "devDependencies": {
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@types/three": "^0.169.0",
    "@typescript-eslint/eslint-plugin": "^7.15.0",
    "@typescript-eslint/parser": "^7.15.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.7",
    "typescript": "^5.5.3",
    "vite": "^5.4.2"
  }
}


```

```typescript
/**
 * Script to upload the depth model to Vercel Blob Storage
 * 
 * Usage:
 * 1. Set BLOB_READ_WRITE_TOKEN in your environment or .env.local
 * 2. Run: npx tsx scripts/upload-model-to-blob.ts
 * 
 * Or use the Vercel CLI:
 * vercel blob put public/models/depth-anything-v2-small.onnx --token YOUR_TOKEN
 */

import { putBlob } from '@vercel/blob'
import { readFileSync } from 'fs'
import { join } from 'path'
import { fileURLToPath } from 'url'
import { dirname } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

async function uploadModel() {
  const token = process.env.BLOB_READ_WRITE_TOKEN
  
  if (!token) {
    console.error('❌ BLOB_READ_WRITE_TOKEN not found in environment')
    console.error('   Set it in .env.local or export it:')
    console.error('   export BLOB_READ_WRITE_TOKEN=your_token_here')
    process.exit(1)
  }

  const modelPath = join(__dirname, '../public/models/depth-anything-v2-small.onnx')
  const blobKey = 'depth-anything-v2-small.onnx'

  try {
    console.log('📤 Reading model file...')
    const fileBuffer = readFileSync(modelPath)
    const fileSizeMB = (fileBuffer.length / (1024 * 1024)).toFixed(2)
    console.log(`   File size: ${fileSizeMB} MB`)

    console.log('📦 Uploading to Vercel Blob Storage...')
    const blob = await putBlob(blobKey, fileBuffer, {
      token,
      contentType: 'application/octet-stream',
      addRandomSuffix: false
    })

    console.log('✅ Model uploaded successfully!')
    console.log(`   Blob URL: ${blob.url}`)
    console.log(`   Blob Key: ${blobKey}`)
    console.log('\n📝 Next steps:')
    console.log('   1. Set BLOB_READ_WRITE_TOKEN in Vercel environment variables')
    console.log('   2. Update config.ts: modelPath: "/api/model"')
    console.log('   3. Deploy to Vercel')
  } catch (error: any) {
    console.error('❌ Upload failed:', error.message)
    process.exit(1)
  }
}

uploadModel()

```

```markdown
# Model Storage Guide for Vercel Deployment

Since the ONNX model file (`depth-anything-v2-small.onnx`) is gitignored (it's ~235MB), it won't be deployed to Vercel. Here are two solutions:

## Option 1: CDN (Recommended - Simplest)

**Use Hugging Face CDN** - The model is already hosted there, no setup needed!

### Setup

1. **No changes needed!** The code is already configured to:
   - Try local model first (`/models/depth-anything-v2-small.onnx`)
   - Automatically fallback to Hugging Face CDN if local not found

2. **For production**, you can explicitly set the CDN URL in `src/config.ts`:
   ```typescript
   modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'
   ```

### Available CDN URLs

- **Small model** (recommended): `https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`
- **Large q4f16** (235MB, best balance): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx`
- **Large fp16** (669MB, high quality): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx`

### Pros
- ✅ Zero setup - works immediately
- ✅ No storage costs
- ✅ Fast CDN delivery
- ✅ No Vercel configuration needed

### Cons
- ⚠️ Depends on external service (Hugging Face)
- ⚠️ First load downloads ~235MB from CDN

---

## Option 2: Vercel Blob Storage

Store the model in Vercel Blob Storage and serve via API route.

### Setup Steps

1. **Install dependencies** (already added):
   ```bash
   npm install
   ```

2. **Get Vercel Blob Token**:
   - Go to [Vercel Dashboard](https://vercel.com/dashboard)
   - Select your project → Settings → Storage
   - Create a new Blob store (or use existing)
   - Copy the `BLOB_READ_WRITE_TOKEN`

3. **Upload the model** (choose one method):

   **Method A: Using Vercel CLI** (recommended):
   ```bash
   # Install Vercel CLI if needed
   npm i -g vercel
   
   # Upload the model
   vercel blob put public/models/depth-anything-v2-small.onnx \
     --token YOUR_BLOB_TOKEN \
     --name depth-anything-v2-small.onnx
   ```

   **Method B: Using the upload script**:
   ```bash
   # Set token in environment
   export BLOB_READ_WRITE_TOKEN=your_token_here
   
   # Run upload script
   npx tsx scripts/upload-model-to-blob.ts
   ```

   **Method C: Using Node.js script**:
   ```javascript
   import { putBlob } from '@vercel/blob'
   import { readFileSync } from 'fs'
   
   const token = 'YOUR_BLOB_TOKEN'
   const file = readFileSync('public/models/depth-anything-v2-small.onnx')
   
   const blob = await putBlob('depth-anything-v2-small.onnx', file, {
     token,
     contentType: 'application/octet-stream'
   })
   
   console.log('Uploaded:', blob.url)
   ```

4. **Set environment variable in Vercel**:
   - Go to Vercel Dashboard → Your Project → Settings → Environment Variables
   - Add: `BLOB_READ_WRITE_TOKEN` = `your_token_here`
   - Redeploy

5. **Update config** (optional - auto-detection works):
   ```typescript
   // In src/config.ts
   modelPath: '/api/model'  // Use Vercel Blob API route
   ```

### How It Works

- The API route (`api/model.ts`) fetches the model from Vercel Blob Storage
- Streams it to the client with proper headers
- Cached by Vercel's CDN for fast delivery

### Pros
- ✅ Self-hosted (no external dependency)
- ✅ Fast delivery via Vercel CDN
- ✅ Integrated with Vercel infrastructure

### Cons
- ⚠️ Requires setup and token management
- ⚠️ Uses Vercel Blob Storage quota
- ⚠️ Slightly more complex than CDN

---

## Current Configuration

The app is configured to **auto-detect**:
1. Try local model first (`/models/depth-anything-v2-small.onnx`)
2. If not found, use CDN fallback (Hugging Face)

This means:
- **Local development**: Uses local file if present
- **Vercel deployment**: Automatically uses CDN (since local file isn't deployed)

### To Force a Specific Source

Edit `src/config.ts`:

```typescript
// Use CDN only
modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'

// Use Vercel Blob API
modelPath: '/api/model'

// Use local only (will fail if not found)
modelPath: '/models/depth-anything-v2-small.onnx'
```

---

## Recommendation

**Start with Option 1 (CDN)** - it requires zero setup and works immediately. The Hugging Face CDN is reliable and fast.

Only use Option 2 (Vercel Blob) if you:
- Need self-hosted storage
- Want more control over the model file
- Have specific compliance/security requirements

---

## Troubleshooting

### Model not loading on Vercel

1. Check browser console for errors
2. Verify the CDN URL is accessible: `curl -I https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`
3. Check network tab - model should download from CDN
4. If using Vercel Blob, verify `BLOB_READ_WRITE_TOKEN` is set correctly

### Slow model loading

- The model is ~235MB, first load will take time
- Subsequent loads are cached by browser
- Consider using a smaller quantized model if needed

### CORS errors

- Hugging Face CDN supports CORS
- If using custom CDN, ensure CORS headers are set

```


Implemented two solutions for storing the model on Vercel:

## Solution implemented

### Option 1: CDN (recommended — works immediately)

The code now auto-detects:
1. Tries local model first (`/models/depth-anything-v2-small.onnx`)
2. Falls back to Hugging Face CDN if local not found

No setup needed. On Vercel, it will use the CDN since the local file isn't deployed.

### Option 2: Vercel Blob Storage

Created:
- `api/model.ts` — API route to serve the model from Vercel Blob
- `scripts/upload-model-to-blob.ts` — Script to upload the model
- Added `@vercel/blob` dependency

To use this option:
1. Get `BLOB_READ_WRITE_TOKEN` from Vercel Dashboard
2. Upload the model: `vercel blob put public/models/depth-anything-v2-small.onnx --token YOUR_TOKEN`
3. Set the token in Vercel environment variables
4. Update `config.ts`: `modelPath: '/api/model'`

## Files changed

1. `src/config.ts` — Added `modelPath` and `modelCdnUrl` configuration
2. `src/components/Viewer.tsx` — Auto-detection logic (local → CDN)
3. `api/model.ts` — Vercel Blob API route (Option 2)
4. `package.json` — Added `@vercel/blob` dependency
5. `MODEL_STORAGE.md` — Documentation for both options

## Recommendation

Use Option 1 (CDN). It works immediately on Vercel without any setup. The app will automatically download the model from Hugging Face CDN when deployed.

The model will load from: `https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`

Deploy to Vercel and it should work.

---

**User**

Explain how you determined the model url on huggingface?

---

**Cursor**


Checking the README for Hugging Face references and verifying the URL pattern:



Explaining how I determined the URL:



How I determined the Hugging Face model URL:

## 1. Found existing URLs in your README

Your README already had Hugging Face URLs for the large model:
```
https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx
```

## 2. Hugging Face URL pattern

Hugging Face uses a standard pattern for direct file downloads:
```
https://huggingface.co/{repo_id}/resolve/{revision}/{file_path}
```

Where:
- `{repo_id}` = `onnx-community/depth-anything-v2-small` (or `-large`)
- `{revision}` = `main` (default branch)
- `{file_path}` = `onnx/model.onnx` (or specific filename)

## 3. Inferred the small model URL

Since your code expects `depth-anything-v2-small.onnx`, I inferred:
- Repository: `onnx-community/depth-anything-v2-small` (mirroring the large repo)
- Path: `onnx/model.onnx` (common structure)

Resulting URL:
```
https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx
```

## Verification

To verify this URL exists, you can:
1. Visit: https://huggingface.co/onnx-community/depth-anything-v2-small/tree/main/onnx
2. Or test the URL directly: `curl -I https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`

If the small model doesn't exist or has a different path, we can:
- Use the large model URL from your README
- Search Hugging Face for the correct small model repository
- Use a different CDN source

Should I verify the URL or use the large model URLs from your README instead?

```plaintext
https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx
```

```plaintext
https://huggingface.co/{repo_id}/resolve/{revision}/{file_path}
```

```plaintext
https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx
```

---

**User**

fold the @MODEL_STORAGE.md into the @README.md instead.

Also, add some kind of indicator on the app hud itself that indicates if the model loaded successfully

---

**Cursor**


Merging MODEL_STORAGE.md into README.md and adding a UI indicator for model load status. Reviewing the current structure:



Checking how model loading is tracked in Viewer:



Merging MODEL_STORAGE.md into README.md, then adding the model status indicator:


```markdown
# Face Follow Cursor PoC

A proof-of-concept web application that makes a portrait image "follow" the cursor using depth-based 2.5D parallax. Built entirely in TypeScript with no Python dependencies.

## Features

- **Upload & Process**: Upload a portrait image and generate a depth map in-browser
- **Depth-Based Parallax**: Real-time 3D parallax effect using Three.js and custom shaders
- **Smooth Motion**: Cursor tracking with dead-zone, EMA smoothing, and angle clamps
- **Adjustable Controls**: Intensity and smoothing sliders
- **Performance Optimized**: Automatic mesh subdivision reduction for lower-end devices

## Tech Stack

- **Frontend**: Vite + React + TypeScript
- **3D Rendering**: Three.js
- **ML Inference**: onnxruntime-web (WASM/WebGL/WebGPU)
- **No Backend**: Fully client-side, suitable for static hosting

## Getting Started

### Prerequisites

- Node.js 18+ and npm

### Installation

```bash
npm install
```

### Setup Environment Variables (Optional, for Atlas Mode)

If you plan to use **Atlas Mode** (dynamic image generation):

1. Copy the example environment file:
   ```bash
   cp .env.local.example .env.local
   ```

2. Add your Replicate API token to `.env.local`:
   ```bash
   REPLICATE_API_TOKEN=r8_your_token_here
   ```

   Get your token from: https://replicate.com/account/api-tokens

3. Restart the dev server for changes to take effect

**Note:** This is only needed for Atlas Mode. Depth Mode works without any configuration.

### Development

```bash
npm run dev
```

### Build

```bash
npm run build
```

### Preview Production Build

```bash
npm run preview
```

## Depth Model Setup

The app uses an ONNX depth estimation model to generate depth maps from uploaded portraits. If no model is provided, it will use a simple fallback depth map (radial gradient) for testing purposes.

### Quick Start

**Just want to get started?** Download this file and place it in `public/models/`:

👉 **[model_q4f16.onnx (235 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx)** ← Recommended

```bash
# Download and place the model
mkdir -p public/models
# Download model_q4f16.onnx to public/models/
# Rename it to match the default path, or update Viewer.tsx
mv public/models/model_q4f16.onnx public/models/depth-anything-v2-small.onnx
```

This is the best balance of size (235 MB), quality, and speed for web deployment.

### Option 1: Using a Pre-built ONNX Model (Recommended)

#### Step 1: Download a Compatible Model

The app expects an ONNX depth estimation model. Here are specific recommendations:

**Depth Anything V2 Large** ([Hugging Face](https://huggingface.co/onnx-community/depth-anything-v2-large/tree/main/onnx))

Multiple quantization options are available. **Recommended: `model_q4f16.onnx` (235 MB)**

| Model File | Size | Quality | Speed | Best For |
|-----------|------|---------|-------|----------|
| `model_q4f16.onnx` | **235 MB** | ⭐⭐⭐⭐ | ⚡⚡⚡ | **Recommended: Best balance** |
| `model_fp16.onnx` | 669 MB | ⭐⭐⭐⭐⭐ | ⚡⚡ | Highest quality |
| `model_int8.onnx` | 347 MB | ⭐⭐⭐ | ⚡⚡⚡ | Good balance |
| `model.onnx` | 1.34 GB | ⭐⭐⭐⭐⭐ | ⚡ | Full precision (too large for web) |

**Which one to choose?**

- **`model_q4f16.onnx` (235 MB)** ← **Start here!**
  - Best size/quality ratio for web apps
  - 4-bit quantization with fp16 precision
  - Fast download and inference
  - Good depth quality for portraits

- **`model_fp16.onnx` (669 MB)**
  - If you need maximum quality
  - Half precision (good quality, smaller than full precision)
  - Still reasonable for web deployment

- **`model_int8.onnx` (347 MB)**
  - Alternative if q4f16 doesn't work well
  - 8-bit integer quantization
  - Good compatibility

**License Note**: Depth Anything V2 Large uses **CC-BY-NC-4.0** (non-commercial only). For commercial use, consider Depth Anything V2 Small (Apache 2.0).

**Direct Download Links:**

1. **Recommended**: [model_q4f16.onnx (235 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx)
2. **High Quality**: [model_fp16.onnx (669 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx)
3. **Alternative**: [model_int8.onnx (347 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_int8.onnx)

**Other Model Sources:**
- **Depth Anything V2 Small**: Better for commercial use (Apache 2.0 license)
- Search Hugging Face: [depth-anything-v2-onnx](https://huggingface.co/models?search=depth+anything+onnx)

#### Step 2: Place the Model File

1. Create the models directory if it doesn't exist:
   ```bash
   mkdir -p public/models
   ```

2. Place your ONNX model file in `public/models/`:
   ```bash
   # Example: if you downloaded depth-anything-v2-small.onnx
   cp /path/to/your/model.onnx public/models/depth-anything-v2-small.onnx
   ```

3. Rename the downloaded file to match what the app expects, or update the path:
   ```bash
   # Rename to the default expected name
   mv model_q4f16.onnx public/models/depth-anything-v2-small.onnx
   
   # OR keep your filename and update the code (see below)
   ```

4. The app looks for `/models/depth-anything-v2-small.onnx` by default. To use a different filename:
   - Update the model path in `src/components/Viewer.tsx` (around line 47):
     ```typescript
     const modelPath = '/models/model_q4f16.onnx'  // or your filename
     ```

#### Step 3: Model Requirements

Your ONNX model should:
- Accept RGB input images (3 channels)
- Output depth predictions (single channel or multi-channel)
- Have input shape `[1, 3, H, W]` (batch, channels, height, width)
- Have normalized input values in range `[0, 1]`

The app handles various output shapes automatically:
- Single channel: `[1, 1, H, W]` or `[1, H, W]`
- Multi-channel: Takes the first channel if multiple are present

### Option 2: Convert a PyTorch/TensorFlow Model to ONNX

If you have a PyTorch or TensorFlow model, convert it to ONNX:

#### From PyTorch:

```python
import torch
import torch.onnx

# Load your PyTorch model
model = YourDepthModel()
model.load_state_dict(torch.load('model.pth'))
model.eval()

# Create dummy input
dummy_input = torch.randn(1, 3, 384, 384)  # Adjust size to your model

# Export to ONNX
torch.onnx.export(
    model,
    dummy_input,
    "depth-model.onnx",
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={'input': {0: 'batch', 2: 'height', 3: 'width'},
                  'output': {0: 'batch', 2: 'height', 3: 'width'}},
    opset_version=11  # or higher
)
```

#### From TensorFlow:

```python
import tensorflow as tf
import tf2onnx

# Load your TensorFlow model
model = tf.keras.models.load_model('model.h5')

# Convert to ONNX
spec = (tf.TensorSpec((None, 384, 384, 3), tf.float32, name="input"),)
output_path = "depth-model.onnx"
tf2onnx.convert.from_keras(model, input_signature=spec, output_path=output_path)
```

### Option 3: Use the Fallback (No Model Required)

If you don't provide a model, the app will automatically use a simple **radial gradient depth map**. This creates a basic parallax effect where:
- The center of the image is "closer" (more displacement)
- The edges are "farther" (less displacement)

**Limitations of fallback:**
- Not as realistic as ML-generated depth
- Works best with centered portraits
- No understanding of actual scene geometry

**When to use fallback:**
- Quick testing/prototyping
- Understanding the UI and cursor tracking
- Testing performance without loading large models

### Model Size Considerations

**Quantized Models (200-350MB)**
- ✅ Fast loading and inference
- ✅ Works well on most devices
- ✅ Good for web deployment
- ✅ Quality is excellent for portraits
- **Example**: `model_q4f16.onnx` (235 MB) ← **Recommended**

**Half Precision Models (600-700MB)**
- ✅ Very high quality depth maps
- ⚠️ Slower initial load (~2-3x longer)
- ⚠️ Requires more memory
- ⚠️ May be slow on lower-end devices
- **Example**: `model_fp16.onnx` (669 MB)

**Full Precision Models (1GB+)**
- ✅ Maximum quality
- ❌ Too large for practical web use
- ❌ Very slow download and inference
- **Not recommended for web apps**

**Recommendation**: 
- **Start with `model_q4f16.onnx` (235 MB)** - best balance
- Only upgrade to `model_fp16.onnx` if you need higher quality and can accept slower loading
- Avoid full precision models (`model.onnx`) for web deployment

### Model Storage for Vercel Deployment

Since the ONNX model file (`depth-anything-v2-small.onnx`) is gitignored (it's ~235MB), it won't be deployed to Vercel. Here are two solutions:

#### Option 1: CDN (Recommended - Simplest)

**Use Hugging Face CDN** - The model is already hosted there, no setup needed!

**Setup:**

1. **No changes needed!** The code is already configured to:
   - Try local model first (`/models/depth-anything-v2-small.onnx`)
   - Automatically fallback to Hugging Face CDN if local not found

2. **For production**, you can explicitly set the CDN URL in `src/config.ts`:
   ```typescript
   modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'
   ```

**Available CDN URLs:**

- **Small model** (recommended): `https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`
- **Large q4f16** (235MB, best balance): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx`
- **Large fp16** (669MB, high quality): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx`

**Pros:**
- ✅ Zero setup - works immediately
- ✅ No storage costs
- ✅ Fast CDN delivery
- ✅ No Vercel configuration needed

**Cons:**
- ⚠️ Depends on external service (Hugging Face)
- ⚠️ First load downloads ~235MB from CDN

#### Option 2: Vercel Blob Storage

Store the model in Vercel Blob Storage and serve via API route.

**Setup Steps:**

1. **Install dependencies** (already added):
   ```bash
   npm install
   ```

2. **Get Vercel Blob Token**:
   - Go to [Vercel Dashboard](https://vercel.com/dashboard)
   - Select your project → Settings → Storage
   - Create a new Blob store (or use existing)
   - Copy the `BLOB_READ_WRITE_TOKEN`

3. **Upload the model** (choose one method):

   **Method A: Using Vercel CLI** (recommended):
   ```bash
   # Install Vercel CLI if needed
   npm i -g vercel
   
   # Upload the model
   vercel blob put public/models/depth-anything-v2-small.onnx \
     --token YOUR_BLOB_TOKEN \
     --name depth-anything-v2-small.onnx
   ```

   **Method B: Using the upload script**:
   ```bash
   # Set token in environment
   export BLOB_READ_WRITE_TOKEN=your_token_here
   
   # Run upload script
   npx tsx scripts/upload-model-to-blob.ts
   ```

4. **Set environment variable in Vercel**:
   - Go to Vercel Dashboard → Your Project → Settings → Environment Variables
   - Add: `BLOB_READ_WRITE_TOKEN` = `your_token_here`
   - Redeploy

5. **Update config** (optional - auto-detection works):
   ```typescript
   // In src/config.ts
   modelPath: '/api/model'  // Use Vercel Blob API route
   ```

**How It Works:**

- The API route (`api/model.ts`) fetches the model from Vercel Blob Storage
- Streams it to the client with proper headers
- Cached by Vercel's CDN for fast delivery

**Pros:**
- ✅ Self-hosted (no external dependency)
- ✅ Fast delivery via Vercel CDN
- ✅ Integrated with Vercel infrastructure

**Cons:**
- ⚠️ Requires setup and token management
- ⚠️ Uses Vercel Blob Storage quota
- ⚠️ Slightly more complex than CDN

**Current Configuration:**

The app is configured to **auto-detect**:
1. Try local model first (`/models/depth-anything-v2-small.onnx`)
2. If not found, use CDN fallback (Hugging Face)

This means:
- **Local development**: Uses local file if present
- **Vercel deployment**: Automatically uses CDN (since local file isn't deployed)

**To Force a Specific Source:**

Edit `src/config.ts`:

```typescript
// Use CDN only
modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'

// Use Vercel Blob API
modelPath: '/api/model'

// Use local only (will fail if not found)
modelPath: '/models/depth-anything-v2-small.onnx'
```

**Recommendation:**

**Start with Option 1 (CDN)** - it requires zero setup and works immediately. The Hugging Face CDN is reliable and fast.

Only use Option 2 (Vercel Blob) if you:
- Need self-hosted storage
- Want more control over the model file
- Have specific compliance/security requirements

### Troubleshooting

**Model won't load:**
- Check browser console for errors
- Verify the file path matches exactly (case-sensitive)
- Ensure the model file is in `public/models/` (not `src/`)
- Check that the file is served correctly (should be accessible at `/models/your-model.onnx`)

**Model loads but inference fails:**
- Check that input shape matches expected format `[1, 3, H, W]`
- Verify output shape is compatible (single or multi-channel depth)
- Check browser console for ONNX Runtime errors
- Try a different execution provider (WebGPU → WebGL → WASM → CPU)

**Slow inference:**
- Use a quantized model (`model_q4f16.onnx` instead of `model_fp16.onnx`)
- Reduce input image size (edit `CONFIG.maxImageWidth` in `src/config.ts`)
- Check which execution provider is being used (check console logs)
- Consider using WebGPU if available (requires compatible browser/GPU)
- The quantized models (q4f16, int8) are significantly faster than fp16

**File too large:**
- Use `model_q4f16.onnx` (235 MB) instead of larger variants
- Consider using Depth Anything V2 Small if available (smaller base model)
- Check if your hosting/CDN has file size limits

### Testing Without a Model

To test the app immediately without downloading a model:

1. Run `npm run dev`
2. Upload a portrait image
3. The app will show "Generating depth map..." briefly
4. It will automatically fall back to the radial gradient depth map
5. You can still test cursor tracking and all UI controls

The fallback works well enough to demonstrate the parallax effect, though it won't be as realistic as ML-generated depth.

## Project Structure

```
src/
├── components/          # React components
│   ├── Upload.tsx      # Image upload dropzone
│   ├── Viewer.tsx      # Three.js viewer with depth parallax
│   └── Controls.tsx    # UI controls (intensity, smoothing, debug)
├── lib/
│   ├── cursor/         # Cursor mapping logic
│   ├── depth/          # Depth inference and processing
│   ├── three/          # Three.js scene setup
│   └── atlas/          # Atlas mode stub (not implemented)
├── shaders/            # GLSL shaders for parallax
└── config.ts           # Configuration constants
```

## Configuration

Edit `src/config.ts` to adjust:

- Angle clamps (yaw ±12°, pitch ±8°)
- Smoothing parameters
- Dead zone size
- Depth scale
- Mesh subdivisions
- Performance thresholds

## Deployment

### Vercel

Vercel automatically detects and deploys serverless functions from the `api/` directory. No special configuration needed!

**Quick Deploy:**

```bash
npm install -g vercel
vercel
```

**Using Atlas Mode (Replicate API):**

If you want to use the dynamic atlas generation feature:

1. **Set Environment Variable in Vercel:**
   - Go to your Vercel project dashboard
   - Navigate to **Settings** → **Environment Variables**
   - Add: `REPLICATE_API_TOKEN` = `your_replicate_api_token`
   - Redeploy your project

2. **For Local Development:**
   Create `.env.local` in the project root:
   ```bash
   REPLICATE_API_TOKEN=your_token_here
   ```

The `api/generate-gaze.ts` file will automatically be deployed as a serverless function at `/api/generate-gaze`. No additional setup required!

**Note:** Serverless functions work with any framework (Vite, Next.js, etc.). Vercel automatically detects files in the `api/` directory and deploys them as serverless functions.

Or connect your GitHub repo to Vercel for automatic deployments on every git push.

## Atlas Mode (Optional)

The app supports **two approaches** for gaze-tracking:

### Option A: Depth-Based Parallax (Default)
- Uses depth maps + Three.js shaders
- Continuous smooth motion
- No external API required
- See "Depth Model Setup" above

### Option B: Pre-Generated Atlas Images
- Uses grid of pre-generated gaze images
- More realistic results (AI-generated)
- Requires image generation step

**Two ways to generate atlas images:**

#### 1. Dynamic Generation via Replicate API (Recommended)

Generate gaze image grids on-demand using the Replicate API. This serverless approach keeps your API key secure and generates images at runtime.

**Overview:**
- **Vercel Serverless Function** (`api/generate-gaze.ts`) - Securely handles Replicate API calls
- **Client-side service** (`src/lib/replicate/generateGaze.ts`) - Makes requests to the serverless function
- **AtlasGenerator component** - UI for generating atlas images on-demand
- No need to pre-generate images; generate as needed

**Setup Steps:**

1. **Get Replicate API Token:**
   - Sign up at [replicate.com](https://replicate.com)
   - Go to [API Tokens](https://replicate.com/account/api-tokens)
   - Create and copy your token

2. **Configure Environment Variable:**

   **For Local Development:**
   Create `.env.local` in project root:
   ```bash
   REPLICATE_API_TOKEN=your_token_here
   ```

   **For Vercel Deployment:**
   - Go to your Vercel project settings
   - Navigate to "Environment Variables"
   - Add `REPLICATE_API_TOKEN` with your token value
   - Redeploy your project

3. **Install Dependencies:**
   The serverless function uses standard Node.js APIs. No additional dependencies required.

4. **Test the Setup:**
   ```bash
   npm run dev
   ```
   Then upload a portrait image and click "Generate Atlas" button

**Usage Examples:**

Generate single image:
```typescript
import { generateGazeImage } from './lib/replicate/generateGaze'

const result = await generateGazeImage({
  image: portraitImage,
  px: 0,  // Horizontal gaze angle
  py: 0,  // Vertical gaze angle
})

console.log(result.imageUrl) // URL to generated image
```

Generate full atlas:
```typescript
import { generateGazeAtlas } from './lib/replicate/generateGaze'

const imageMap = await generateGazeAtlas(
  portraitImage,
  -15, // min
  15,  // max
  3,   // step
  (completed, total) => {
    console.log(`Progress: ${completed}/${total}`)
  }
)

// imageMap is Map<string, string>
// Keys: "px-15_py-15", "px-15_py-12", etc.
// Values: Image URLs from Replicate
```

**Architecture:**

```
React App (Browser)
    ↓ HTTP POST /api/generate-gaze
Vercel Serverless Function
    ↓ HTTPS + API Token
Replicate API (fofr/expression-editor)
    ↓ Generated Image URL
Display/Cache in Browser
```

**API Function Details:**

**Endpoint:** `POST /api/generate-gaze`

**Request Body:**
```json
{
  "image": "base64_encoded_image_string",
  "px": 0,
  "py": 0
}
```

**Success Response:**
```json
{
  "success": true,
  "imageUrl": "https://replicate.delivery/...",
  "px": 0,
  "py": 0
}
```

**Error Response:**
```json
{
  "error": "Error message here"
}
```

**Cost Estimation:**
- Per image: ~$0.0001
- Full atlas (121 images): ~$0.01-0.02
- Test set (25 images): ~$0.0025

See [Replicate Pricing](https://replicate.com/pricing) for current rates.

**Security Notes:**
- ✅ API key never exposed to client - only used in serverless function
- ✅ Serverless function validates all input
- ✅ Error handling with graceful failures
- ⚠️ Consider adding usage limits or user confirmation for large batches

**Troubleshooting:**

**"REPLICATE_API_TOKEN not configured"**
- Make sure `.env.local` exists and contains the token
- For Vercel: Check environment variables in project settings
- Restart dev server after adding `.env.local`

**CORS Errors**
- Make sure you're calling `/api/generate-gaze` (relative path)
- The serverless function handles CORS automatically

**Generation Timeout**
- Single image generation takes ~2-10 seconds
- Full atlas (121 images) takes ~5-20 minutes
- Function polls for up to 60 seconds per image
- For faster results, use smaller step values or generate in batches

**Rate Limits**
- Replicate may have rate limits on free tier
- Code generates images sequentially to avoid limits
- Consider adding delays between requests if needed

#### 2. Offline Generation via Python Script

Pre-generate atlas images locally using the Python script from the reference implementation.

**Overview:**
- Use the Python script from [kylan02/face_looker](https://github.com/kylan02/face_looker) repo
- Uses `fofr/expression-editor` model on Replicate
- Requires: Python, Replicate API token
- Supports resume via `--skip-existing` flag

**Setup:**

1. Clone or reference the [kylan02/face_looker](https://github.com/kylan02/face_looker) repository
2. Set environment variable: `export REPLICATE_API_TOKEN=your_token_here`
3. Install dependencies: `pip install replicate`

**Generation:**

```bash
python main.py \
  --image ./portrait.jpg \
  --out ./out \
  --min -15 \
  --max 15 \
  --step 3 \
  --size 256 \
  --skip-existing  # Resume interrupted generation
```

**Parameters:**
- `px`/`py` in [-15, 15] with configurable step → ~121 images at 256×256 (11×11 grid with step=3)
- Naming pattern: `gaze_px{X}_py{Y}_256.webp`
  - Negative values use 'm' prefix: `gaze_pxm15_pym15_256.webp`
  - Positive values: `gaze_px15_py15_256.webp`
  - Zero/center: `gaze_px0_py0_256.webp`

**Output Structure:**
```
out/
  ├── gaze_px-15_py-15_256.webp
  ├── gaze_px-15_py-12_256.webp
  ├── ...
  ├── gaze_px15_py15_256.webp
  └── index.csv  # Optional CSV mapping
```

**Deployment:**
1. Generate images locally
2. Copy to `public/faces/` directory
3. Use existing `AtlasViewer` component

**When to Use:**
- Free (after initial cost of generation)
- All images pre-generated and ready
- Requires manual generation steps before deployment
- Good for static hosting where you want predictable costs

**Cost:**
- ~$0.0001 per image on Replicate
- 121 images (default): ~$0.01
- 169 images (step=2.5): ~$0.02
- One-time cost; free to deploy

## Limitations

- Requires WebGL support for depth-based rendering
- Depth model must be downloaded separately (or use fallback)
- Atlas mode requires setup (either Replicate API token or pre-generated images)
- Eye tracking is stubbed (placeholder)

## Future Enhancements

- Atlas mode implementation (pre-generated gaze grid)
- Eye tracking overlay
- Mobile optimizations
- Model hosting/CDN integration
- Shareable URLs with embedded depth data

## References

- Research document: `RESEARCH.md`
- Atlas setup guide: `ATLAS_SETUP.md`
- Replicate integration: `REPLICATE_INTEGRATION.md`
- Atlas approach reference: [kylan02/face_looker](https://github.com/kylan02/face_looker)

## License

MIT


```

```markdown
# Face Follow Cursor PoC

A proof-of-concept web application that makes a portrait image "follow" the cursor using depth-based 2.5D parallax. Built entirely in TypeScript with no Python dependencies.

## Features

- **Upload & Process**: Upload a portrait image and generate a depth map in-browser
- **Depth-Based Parallax**: Real-time 3D parallax effect using Three.js and custom shaders
- **Smooth Motion**: Cursor tracking with dead-zone, EMA smoothing, and angle clamps
- **Adjustable Controls**: Intensity and smoothing sliders
- **Performance Optimized**: Automatic mesh subdivision reduction for lower-end devices

## Tech Stack

- **Frontend**: Vite + React + TypeScript
- **3D Rendering**: Three.js
- **ML Inference**: onnxruntime-web (WASM/WebGL/WebGPU)
- **No Backend**: Fully client-side, suitable for static hosting

## Getting Started

### Prerequisites

- Node.js 18+ and npm

### Installation

```bash
npm install
```

### Setup Environment Variables (Optional, for Atlas Mode)

If you plan to use **Atlas Mode** (dynamic image generation):

1. Copy the example environment file:
   ```bash
   cp .env.local.example .env.local
   ```

2. Add your Replicate API token to `.env.local`:
   ```bash
   REPLICATE_API_TOKEN=r8_your_token_here
   ```

   Get your token from: https://replicate.com/account/api-tokens

3. Restart the dev server for changes to take effect

**Note:** This is only needed for Atlas Mode. Depth Mode works without any configuration.

### Development

```bash
npm run dev
```

### Build

```bash
npm run build
```

### Preview Production Build

```bash
npm run preview
```

## Depth Model Setup

The app uses an ONNX depth estimation model to generate depth maps from uploaded portraits. If no model is provided, it will use a simple fallback depth map (radial gradient) for testing purposes.

### Quick Start

**Just want to get started?** Download this file and place it in `public/models/`:

👉 **[model_q4f16.onnx (235 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx)** ← Recommended

```bash
# Download and place the model
mkdir -p public/models
# Download model_q4f16.onnx to public/models/
# Rename it to match the default path, or update Viewer.tsx
mv public/models/model_q4f16.onnx public/models/depth-anything-v2-small.onnx
```

This is the best balance of size (235 MB), quality, and speed for web deployment.

### Option 1: Using a Pre-built ONNX Model (Recommended)

#### Step 1: Download a Compatible Model

The app expects an ONNX depth estimation model. Here are specific recommendations:

**Depth Anything V2 Large** ([Hugging Face](https://huggingface.co/onnx-community/depth-anything-v2-large/tree/main/onnx))

Multiple quantization options are available. **Recommended: `model_q4f16.onnx` (235 MB)**

| Model File | Size | Quality | Speed | Best For |
|-----------|------|---------|-------|----------|
| `model_q4f16.onnx` | **235 MB** | ⭐⭐⭐⭐ | ⚡⚡⚡ | **Recommended: Best balance** |
| `model_fp16.onnx` | 669 MB | ⭐⭐⭐⭐⭐ | ⚡⚡ | Highest quality |
| `model_int8.onnx` | 347 MB | ⭐⭐⭐ | ⚡⚡⚡ | Good balance |
| `model.onnx` | 1.34 GB | ⭐⭐⭐⭐⭐ | ⚡ | Full precision (too large for web) |

**Which one to choose?**

- **`model_q4f16.onnx` (235 MB)** ← **Start here!**
  - Best size/quality ratio for web apps
  - 4-bit quantization with fp16 precision
  - Fast download and inference
  - Good depth quality for portraits

- **`model_fp16.onnx` (669 MB)**
  - If you need maximum quality
  - Half precision (good quality, smaller than full precision)
  - Still reasonable for web deployment

- **`model_int8.onnx` (347 MB)**
  - Alternative if q4f16 doesn't work well
  - 8-bit integer quantization
  - Good compatibility

**License Note**: Depth Anything V2 Large uses **CC-BY-NC-4.0** (non-commercial only). For commercial use, consider Depth Anything V2 Small (Apache 2.0).

**Direct Download Links:**

1. **Recommended**: [model_q4f16.onnx (235 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx)
2. **High Quality**: [model_fp16.onnx (669 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx)
3. **Alternative**: [model_int8.onnx (347 MB)](https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_int8.onnx)

**Other Model Sources:**
- **Depth Anything V2 Small**: Better for commercial use (Apache 2.0 license)
- Search Hugging Face: [depth-anything-v2-onnx](https://huggingface.co/models?search=depth+anything+onnx)

#### Step 2: Place the Model File

1. Create the models directory if it doesn't exist:
   ```bash
   mkdir -p public/models
   ```

2. Place your ONNX model file in `public/models/`:
   ```bash
   # Example: if you downloaded depth-anything-v2-small.onnx
   cp /path/to/your/model.onnx public/models/depth-anything-v2-small.onnx
   ```

3. Rename the downloaded file to match what the app expects, or update the path:
   ```bash
   # Rename to the default expected name
   mv model_q4f16.onnx public/models/depth-anything-v2-small.onnx
   
   # OR keep your filename and update the code (see below)
   ```

4. The app looks for `/models/depth-anything-v2-small.onnx` by default. To use a different filename:
   - Update the model path in `src/components/Viewer.tsx` (around line 47):
     ```typescript
     const modelPath = '/models/model_q4f16.onnx'  // or your filename
     ```

#### Step 3: Model Requirements

Your ONNX model should:
- Accept RGB input images (3 channels)
- Output depth predictions (single channel or multi-channel)
- Have input shape `[1, 3, H, W]` (batch, channels, height, width)
- Have normalized input values in range `[0, 1]`

The app handles various output shapes automatically:
- Single channel: `[1, 1, H, W]` or `[1, H, W]`
- Multi-channel: Takes the first channel if multiple are present

### Option 2: Convert a PyTorch/TensorFlow Model to ONNX

If you have a PyTorch or TensorFlow model, convert it to ONNX:

#### From PyTorch:

```python
import torch
import torch.onnx

# Load your PyTorch model
model = YourDepthModel()
model.load_state_dict(torch.load('model.pth'))
model.eval()

# Create dummy input
dummy_input = torch.randn(1, 3, 384, 384)  # Adjust size to your model

# Export to ONNX
torch.onnx.export(
    model,
    dummy_input,
    "depth-model.onnx",
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={'input': {0: 'batch', 2: 'height', 3: 'width'},
                  'output': {0: 'batch', 2: 'height', 3: 'width'}},
    opset_version=11  # or higher
)
```

#### From TensorFlow:

```python
import tensorflow as tf
import tf2onnx

# Load your TensorFlow model
model = tf.keras.models.load_model('model.h5')

# Convert to ONNX
spec = (tf.TensorSpec((None, 384, 384, 3), tf.float32, name="input"),)
output_path = "depth-model.onnx"
tf2onnx.convert.from_keras(model, input_signature=spec, output_path=output_path)
```

### Option 3: Use the Fallback (No Model Required)

If you don't provide a model, the app will automatically use a simple **radial gradient depth map**. This creates a basic parallax effect where:
- The center of the image is "closer" (more displacement)
- The edges are "farther" (less displacement)

**Limitations of fallback:**
- Not as realistic as ML-generated depth
- Works best with centered portraits
- No understanding of actual scene geometry

**When to use fallback:**
- Quick testing/prototyping
- Understanding the UI and cursor tracking
- Testing performance without loading large models

### Model Size Considerations

**Quantized Models (200-350MB)**
- ✅ Fast loading and inference
- ✅ Works well on most devices
- ✅ Good for web deployment
- ✅ Quality is excellent for portraits
- **Example**: `model_q4f16.onnx` (235 MB) ← **Recommended**

**Half Precision Models (600-700MB)**
- ✅ Very high quality depth maps
- ⚠️ Slower initial load (~2-3x longer)
- ⚠️ Requires more memory
- ⚠️ May be slow on lower-end devices
- **Example**: `model_fp16.onnx` (669 MB)

**Full Precision Models (1GB+)**
- ✅ Maximum quality
- ❌ Too large for practical web use
- ❌ Very slow download and inference
- **Not recommended for web apps**

**Recommendation**: 
- **Start with `model_q4f16.onnx` (235 MB)** - best balance
- Only upgrade to `model_fp16.onnx` if you need higher quality and can accept slower loading
- Avoid full precision models (`model.onnx`) for web deployment

### Model Storage for Vercel Deployment

Since the ONNX model file (`depth-anything-v2-small.onnx`) is gitignored (it's ~235MB), it won't be deployed to Vercel. Here are two solutions:

#### Option 1: CDN (Recommended - Simplest)

**Use Hugging Face CDN** - The model is already hosted there, no setup needed!

**Setup:**

1. **No changes needed!** The code is already configured to:
   - Try local model first (`/models/depth-anything-v2-small.onnx`)
   - Automatically fallback to Hugging Face CDN if local not found

2. **For production**, you can explicitly set the CDN URL in `src/config.ts`:
   ```typescript
   modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'
   ```

**Available CDN URLs:**

- **Small model** (recommended): `https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`
- **Large q4f16** (235MB, best balance): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_q4f16.onnx`
- **Large fp16** (669MB, high quality): `https://huggingface.co/onnx-community/depth-anything-v2-large/resolve/main/onnx/model_fp16.onnx`

**Pros:**
- ✅ Zero setup - works immediately
- ✅ No storage costs
- ✅ Fast CDN delivery
- ✅ No Vercel configuration needed

**Cons:**
- ⚠️ Depends on external service (Hugging Face)
- ⚠️ First load downloads ~235MB from CDN

#### Option 2: Vercel Blob Storage

Store the model in Vercel Blob Storage and serve via API route.

**Setup Steps:**

1. **Install dependencies** (already added):
   ```bash
   npm install
   ```

2. **Get Vercel Blob Token**:
   - Go to [Vercel Dashboard](https://vercel.com/dashboard)
   - Select your project → Settings → Storage
   - Create a new Blob store (or use existing)
   - Copy the `BLOB_READ_WRITE_TOKEN`

3. **Upload the model** (choose one method):

   **Method A: Using Vercel CLI** (recommended):
   ```bash
   # Install Vercel CLI if needed
   npm i -g vercel
   
   # Upload the model
   vercel blob put public/models/depth-anything-v2-small.onnx \
     --token YOUR_BLOB_TOKEN \
     --name depth-anything-v2-small.onnx
   ```

   **Method B: Using the upload script**:
   ```bash
   # Set token in environment
   export BLOB_READ_WRITE_TOKEN=your_token_here
   
   # Run upload script
   npx tsx scripts/upload-model-to-blob.ts
   ```

4. **Set environment variable in Vercel**:
   - Go to Vercel Dashboard → Your Project → Settings → Environment Variables
   - Add: `BLOB_READ_WRITE_TOKEN` = `your_token_here`
   - Redeploy

5. **Update config** (optional - auto-detection works):
   ```typescript
   // In src/config.ts
   modelPath: '/api/model'  // Use Vercel Blob API route
   ```

**How It Works:**

- The API route (`api/model.ts`) fetches the model from Vercel Blob Storage
- Streams it to the client with proper headers
- Cached by Vercel's CDN for fast delivery

**Pros:**
- ✅ Self-hosted (no external dependency)
- ✅ Fast delivery via Vercel CDN
- ✅ Integrated with Vercel infrastructure

**Cons:**
- ⚠️ Requires setup and token management
- ⚠️ Uses Vercel Blob Storage quota
- ⚠️ Slightly more complex than CDN

**Current Configuration:**

The app is configured to **auto-detect**:
1. Try local model first (`/models/depth-anything-v2-small.onnx`)
2. If not found, use CDN fallback (Hugging Face)

This means:
- **Local development**: Uses local file if present
- **Vercel deployment**: Automatically uses CDN (since local file isn't deployed)

**To Force a Specific Source:**

Edit `src/config.ts`:

```typescript
// Use CDN only
modelPath: 'https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx'

// Use Vercel Blob API
modelPath: '/api/model'

// Use local only (will fail if not found)
modelPath: '/models/depth-anything-v2-small.onnx'
```

**Recommendation:**

**Start with Option 1 (CDN)** - it requires zero setup and works immediately. The Hugging Face CDN is reliable and fast.

Only use Option 2 (Vercel Blob) if you:
- Need self-hosted storage
- Want more control over the model file
- Have specific compliance/security requirements

### Troubleshooting

**Model won't load:**
- Check browser console for errors
- Verify the file path matches exactly (case-sensitive)
- Ensure the model file is in `public/models/` (not `src/`)
- Check that the file is served correctly (should be accessible at `/models/your-model.onnx`)

**Model loads but inference fails:**
- Check that input shape matches expected format `[1, 3, H, W]`
- Verify output shape is compatible (single or multi-channel depth)
- Check browser console for ONNX Runtime errors
- Try a different execution provider (WebGPU → WebGL → WASM → CPU)

**Slow inference:**
- Use a quantized model (`model_q4f16.onnx` instead of `model_fp16.onnx`)
- Reduce input image size (edit `CONFIG.maxImageWidth` in `src/config.ts`)
- Check which execution provider is being used (check console logs)
- Consider using WebGPU if available (requires compatible browser/GPU)
- The quantized models (q4f16, int8) are significantly faster than fp16

**File too large:**
- Use `model_q4f16.onnx` (235 MB) instead of larger variants
- Consider using Depth Anything V2 Small if available (smaller base model)
- Check if your hosting/CDN has file size limits

**Model not loading on Vercel:**
- Check browser console for errors
- Verify the CDN URL is accessible: `curl -I https://huggingface.co/onnx-community/depth-anything-v2-small/resolve/main/onnx/model.onnx`
- Check network tab - model should download from CDN
- If using Vercel Blob, verify `BLOB_READ_WRITE_TOKEN` is set correctly

**Slow model loading:**
- The model is ~235MB, first load will take time
- Subsequent loads are cached by browser
- Consider using a smaller quantized model if needed

**CORS errors:**
- Hugging Face CDN supports CORS
- If using custom CDN, ensure CORS headers are set

### Testing Without a Model

To test the app immediately without downloading a model:

1. Run `npm run dev`
2. Upload a portrait image
3. The app will show "Generating depth map..." briefly
4. It will automatically fall back to the radial gradient depth map
5. You can still test cursor tracking and all UI controls

The fallback works well enough to demonstrate the parallax effect, though it won't be as realistic as ML-generated depth.

## Project Structure

```
src/
├── components/          # React components
│   ├── Upload.tsx      # Image upload dropzone
│   ├── Viewer.tsx      # Three.js viewer with depth parallax
│   └── Controls.tsx    # UI controls (intensity, smoothing, debug)
├── lib/
│   ├── cursor/         # Cursor mapping logic
│   ├── depth/          # Depth inference and processing
│   ├── three/          # Three.js scene setup
│   └── atlas/          # Atlas mode stub (not implemented)
├── shaders/            # GLSL shaders for parallax
└── config.ts           # Configuration constants
```

## Configuration

Edit `src/config.ts` to adjust:

- Angle clamps (yaw ±12°, pitch ±8°)
- Smoothing parameters
- Dead zone size
- Depth scale
- Mesh subdivisions
- Performance thresholds

## Deployment

### Vercel

Vercel automatically detects and deploys serverless functions from the `api/` directory. No special configuration needed!

**Quick Deploy:**

```bash
npm install -g vercel
vercel
```

**Using Atlas Mode (Replicate API):**

If you want to use the dynamic atlas generation feature:

1. **Set Environment Variable in Vercel:**
   - Go to your Vercel project dashboard
   - Navigate to **Settings** → **Environment Variables**
   - Add: `REPLICATE_API_TOKEN` = `your_replicate_api_token`
   - Redeploy your project

2. **For Local Development:**
   Create `.env.local` in the project root:
   ```bash
   REPLICATE_API_TOKEN=your_token_here
   ```

The `api/generate-gaze.ts` file will automatically be deployed as a serverless function at `/api/generate-gaze`. No additional setup required!

**Note:** Serverless functions work with any framework (Vite, Next.js, etc.). Vercel automatically detects files in the `api/` directory and deploys them as serverless functions.

Or connect your GitHub repo to Vercel for automatic deployments on every git push.

## Atlas Mode (Optional)

The app supports **two approaches** for gaze-tracking:

### Option A: Depth-Based Parallax (Default)
- Uses depth maps + Three.js shaders
- Continuous smooth motion
- No external API required
- See "Depth Model Setup" above

### Option B: Pre-Generated Atlas Images
- Uses grid of pre-generated gaze images
- More realistic results (AI-generated)
- Requires image generation step

**Two ways to generate atlas images:**

#### 1. Dynamic Generation via Replicate API (Recommended)

Generate gaze image grids on-demand using the Replicate API. This serverless approach keeps your API key secure and generates images at runtime.

**Overview:**
- **Vercel Serverless Function** (`api/generate-gaze.ts`) - Securely handles Replicate API calls
- **Client-side service** (`src/lib/replicate/generateGaze.ts`) - Makes requests to the serverless function
- **AtlasGenerator component** - UI for generating atlas images on-demand
- No need to pre-generate images; generate as needed

**Setup Steps:**

1. **Get Replicate API Token:**
   - Sign up at [replicate.com](https://replicate.com)
   - Go to [API Tokens](https://replicate.com/account/api-tokens)
   - Create and copy your token

2. **Configure Environment Variable:**

   **For Local Development:**
   Create `.env.local` in project root:
   ```bash
   REPLICATE_API_TOKEN=your_token_here
   ```

   **For Vercel Deployment:**
   - Go to your Vercel project settings
   - Navigate to "Environment Variables"
   - Add `REPLICATE_API_TOKEN` with your token value
   - Redeploy your project

3. **Install Dependencies:**
   The serverless function uses standard Node.js APIs. No additional dependencies required.

4. **Test the Setup:**
   ```bash
   npm run dev
   ```
   Then upload a portrait image and click "Generate Atlas" button

**Usage Examples:**

Generate single image:
```typescript
import { generateGazeImage } from './lib/replicate/generateGaze'

const result = await generateGazeImage({
  image: portraitImage,
  px: 0,  // Horizontal gaze angle
  py: 0,  // Vertical gaze angle
})

console.log(result.imageUrl) // URL to generated image
```

Generate full atlas:
```typescript
import { generateGazeAtlas } from './lib/replicate/generateGaze'

const imageMap = await generateGazeAtlas(
  portraitImage,
  -15, // min
  15,  // max
  3,   // step
  (completed, total) => {
    console.log(`Progress: ${completed}/${total}`)
  }
)

// imageMap is Map<string, string>
// Keys: "px-15_py-15", "px-15_py-12", etc.
// Values: Image URLs from Replicate
```

**Architecture:**

```
React App (Browser)
    ↓ HTTP POST /api/generate-gaze
Vercel Serverless Function
    ↓ HTTPS + API Token
Replicate API (fofr/expression-editor)
    ↓ Generated Image URL
Display/Cache in Browser
```

**API Function Details:**

**Endpoint:** `POST /api/generate-gaze`

**Request Body:**
```json
{
  "image": "base64_encoded_image_string",
  "px": 0,
  "py": 0
}
```

**Success Response:**
```json
{
  "success": true,
  "imageUrl": "https://replicate.delivery/...",
  "px": 0,
  "py": 0
}
```

**Error Response:**
```json
{
  "error": "Error message here"
}
```

**Cost Estimation:**
- Per image: ~$0.0001
- Full atlas (121 images): ~$0.01-0.02
- Test set (25 images): ~$0.0025

See [Replicate Pricing](https://replicate.com/pricing) for current rates.

**Security Notes:**
- ✅ API key never exposed to client - only used in serverless function
- ✅ Serverless function validates all input
- ✅ Error handling with graceful failures
- ⚠️ Consider adding usage limits or user confirmation for large batches

**Troubleshooting:**

**"REPLICATE_API_TOKEN not configured"**
- Make sure `.env.local` exists and contains the token
- For Vercel: Check environment variables in project settings
- Restart dev server after adding `.env.local`

**CORS Errors**
- Make sure you're calling `/api/generate-gaze` (relative path)
- The serverless function handles CORS automatically

**Generation Timeout**
- Single image generation takes ~2-10 seconds
- Full atlas (121 images) takes ~5-20 minutes
- Function polls for up to 60 seconds per image
- For faster results, use smaller step values or generate in batches

**Rate Limits**
- Replicate may have rate limits on free tier
- Code generates images sequentially to avoid limits
- Consider adding delays between requests if needed

#### 2. Offline Generation via Python Script

Pre-generate atlas images locally using the Python script from the reference implementation.

**Overview:**
- Use the Python script from [kylan02/face_looker](https://github.com/kylan02/face_looker) repo
- Uses `fofr/expression-editor` model on Replicate
- Requires: Python, Replicate API token
- Supports resume via `--skip-existing` flag

**Setup:**

1. Clone or reference the [kylan02/face_looker](https://github.com/kylan02/face_looker) repository
2. Set environment variable: `export REPLICATE_API_TOKEN=your_token_here`
3. Install dependencies: `pip install replicate`

**Generation:**

```bash
python main.py \
  --image ./portrait.jpg \
  --out ./out \
  --min -15 \
  --max 15 \
  --step 3 \
  --size 256 \
  --skip-existing  # Resume interrupted generation
```

**Parameters:**
- `px`/`py` in [-15, 15] with configurable step → ~121 images at 256×256 (11×11 grid with step=3)
- Naming pattern: `gaze_px{X}_py{Y}_256.webp`
  - Negative values use 'm' prefix: `gaze_pxm15_pym15_256.webp`
  - Positive values: `gaze_px15_py15_256.webp`
  - Zero/center: `gaze_px0_py0_256.webp`

**Output Structure:**
```
out/
  ├── gaze_px-15_py-15_256.webp
  ├── gaze_px-15_py-12_256.webp
  ├── ...
  ├── gaze_px15_py15_256.webp
  └── index.csv  # Optional CSV mapping
```

**Deployment:**
1. Generate images locally
2. Copy to `public/faces/` directory
3. Use existing `AtlasViewer` component

**When to Use:**
- Free (after initial cost of generation)
- All images pre-generated and ready
- Requires manual generation steps before deployment
- Good for static hosting where you want predictable costs

**Cost:**
- ~$0.0001 per image on Replicate
- 121 images (default): ~$0.01
- 169 images (step=2.5): ~$0.02
- One-time cost; free to deploy

## Limitations

- Requires WebGL support for depth-based rendering
- Depth model must be downloaded separately (or use fallback)
- Atlas mode requires setup (either Replicate API token or pre-generated images)
- Eye tracking is stubbed (placeholder)

## Future Enhancements

- Atlas mode implementation (pre-generated gaze grid)
- Eye tracking overlay
- Mobile optimizations
- Model hosting/CDN integration
- Shareable URLs with embedded depth data

## References

- Research document: `RESEARCH.md`
- Atlas setup guide: `ATLAS_SETUP.md`
- Replicate integration: `REPLICATE_INTEGRATION.md`
- Atlas approach reference: [kylan02/face_looker](https://github.com/kylan02/face_looker)

## License

MIT


```


Deleting MODEL_STORAGE.md and adding the model status indicator:



Adding model status tracking to Viewer and displaying it in Controls:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        let modelSource: 'local' | 'cdn' | 'configured' = 'configured'
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              modelSource = 'local'
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              modelSource = 'cdn'
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
          modelSource = modelPath.startsWith('http') ? 'cdn' : 'local'
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        let modelSource: 'local' | 'cdn' | 'configured' = 'configured'
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              modelSource = 'local'
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              modelSource = 'cdn'
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
          modelSource = modelPath.startsWith('http') ? 'cdn' : 'local'
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        let modelSource: 'local' | 'cdn' | 'configured' = 'configured'
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              modelSource = 'local'
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              modelSource = 'cdn'
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
          modelSource = modelPath.startsWith('http') ? 'cdn' : 'local'
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Finding where Controls is rendered and adding the modelStatus prop:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        let modelSource: 'local' | 'cdn' | 'configured' = 'configured'
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              modelSource = 'local'
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              modelSource = 'cdn'
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
          modelSource = modelPath.startsWith('http') ? 'cdn' : 'local'
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import './Controls.css'

interface ControlsProps {
  intensity: number
  smoothing: number
  showDebug: boolean
  yawRange: number
  pitchRange: number
  deadZonePercent: number
  depthEnabled: boolean
  cursorHidden: boolean
  onIntensityChange: (value: number) => void
  onSmoothingChange: (value: number) => void
  onYawRangeChange: (value: number) => void
  onPitchRangeChange: (value: number) => void
  onDeadZoneChange: (value: number) => void
  onDepthEnabledChange: (enabled: boolean) => void
  onCursorHiddenChange: (hidden: boolean) => void
  onToggleDebug: () => void
  onReset: () => void
  rotation: { yaw: number; pitch: number }
  fps: number
  // Model status
  modelStatus?: 'loading' | 'loaded' | 'fallback' | null
  // Atlas mode props
  atlasEnabled?: boolean
  atlasGridCoords?: { px: number; py: number } | null
  atlasError?: string | null
  atlasCached?: boolean
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
}

/**
 * UI controls for intensity, smoothing, debug info, and atlas mode
 */
export default function Controls({
  intensity,
  smoothing,
  showDebug,
  yawRange,
  pitchRange,
  deadZonePercent,
  depthEnabled,
  cursorHidden,
  onIntensityChange,
  onSmoothingChange,
  onYawRangeChange,
  onPitchRangeChange,
  onDeadZoneChange,
  onDepthEnabledChange,
  onCursorHiddenChange,
  onToggleDebug,
  onReset,
  rotation,
  fps,
  // Atlas mode props
  atlasEnabled,
  atlasGridCoords,
  atlasError,
  atlasCached,
  onGenerateAtlas,
  onResetAtlas
}: ControlsProps) {
  return (
    <div className="controls">
      <div className="controls-panel">
        {/* Depth Effect Master Toggle */}
        <div className="control-group depth-toggle">
          <label htmlFor="depthToggle">
            <input
              id="depthToggle"
              type="checkbox"
              checked={depthEnabled}
              onChange={(e) => onDepthEnabledChange(e.target.checked)}
            />
            Enable Depth Effect
          </label>
        </div>

        {/* Cursor Visibility Toggle */}
        <div className="control-group cursor-toggle">
          <label htmlFor="cursorToggle">
            <input
              id="cursorToggle"
              type="checkbox"
              checked={!cursorHidden}
              onChange={(e) => onCursorHiddenChange(!e.target.checked)}
            />
            Show Cursor
          </label>
        </div>

        {/* Depth Effect Sliders (only visible when depth is enabled) */}
        {depthEnabled && (
          <>
            <div className="control-group">
              <label htmlFor="intensity">
                Intensity: {intensity}%
              </label>
              <input
                id="intensity"
                type="range"
                min="0"
                max="100"
                value={intensity}
                onChange={(e) => onIntensityChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="smoothing">
                Smoothing: {smoothing}%
              </label>
              <input
                id="smoothing"
                type="range"
                min="0"
                max="100"
                value={smoothing}
                onChange={(e) => onSmoothingChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="yawRange">
                Yaw range: {yawRange.toFixed(0)}°
              </label>
              <input
                id="yawRange"
                type="range"
                min="0"
                max="30"
                value={yawRange}
                onChange={(e) => onYawRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="pitchRange">
                Pitch range: {pitchRange.toFixed(0)}°
              </label>
              <input
                id="pitchRange"
                type="range"
                min="0"
                max="20"
                value={pitchRange}
                onChange={(e) => onPitchRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="deadZone">
                Dead zone: {deadZonePercent.toFixed(0)}%
              </label>
              <input
                id="deadZone"
                type="range"
                min="0"
                max="20"
                value={deadZonePercent}
                onChange={(e) => onDeadZoneChange(Number(e.target.value))}
              />
            </div>
          </>
        )}

        <div className="control-group">
          <button onClick={onToggleDebug} className={showDebug ? 'active' : ''}>
            {showDebug ? 'Hide' : 'Show'} Debug
          </button>
          <button onClick={onReset}>Reset</button>
        </div>

        {/* Atlas mode controls */}
        <div className="control-group atlas-controls">
          {!atlasEnabled && onGenerateAtlas && (
            <button onClick={onGenerateAtlas} className="atlas-generate-btn">
              Generate Atlas
            </button>
          )}

          {atlasEnabled && (
            <div className="atlas-status">
              <div className="atlas-status-info">
                <span className="atlas-status-label">
                  Atlas Active
                  {atlasCached && <span className="atlas-cached-badge" title="Atlas loaded from cache">📦 Cached</span>}
                </span>
                {atlasGridCoords && (
                  <span className="atlas-grid-coords">
                    px: {atlasGridCoords.px}, py: {atlasGridCoords.py}
                  </span>
                )}
              </div>
              {onResetAtlas && (
                <button onClick={onResetAtlas} className="atlas-reset-btn">
                  Clear Atlas
                </button>
              )}
            </div>
          )}

          {atlasError && (
            <div className="atlas-error">
              ⚠️ {atlasError}
            </div>
          )}
        </div>
      </div>

      {showDebug && (
        <div className="debug-panel">
          <div className="debug-item">
            <span className="debug-label">Yaw:</span>
            <span className="debug-value">{rotation.yaw.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">Pitch:</span>
            <span className="debug-value">{rotation.pitch.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">FPS:</span>
            <span className="debug-value">{fps}</span>
          </div>
        </div>
      )}
    </div>
  )
}


```

```typescriptreact
import './Controls.css'

interface ControlsProps {
  intensity: number
  smoothing: number
  showDebug: boolean
  yawRange: number
  pitchRange: number
  deadZonePercent: number
  depthEnabled: boolean
  cursorHidden: boolean
  onIntensityChange: (value: number) => void
  onSmoothingChange: (value: number) => void
  onYawRangeChange: (value: number) => void
  onPitchRangeChange: (value: number) => void
  onDeadZoneChange: (value: number) => void
  onDepthEnabledChange: (enabled: boolean) => void
  onCursorHiddenChange: (hidden: boolean) => void
  onToggleDebug: () => void
  onReset: () => void
  rotation: { yaw: number; pitch: number }
  fps: number
  // Model status
  modelStatus?: 'loading' | 'loaded' | 'fallback' | null
  // Atlas mode props
  atlasEnabled?: boolean
  atlasGridCoords?: { px: number; py: number } | null
  atlasError?: string | null
  atlasCached?: boolean
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
}

/**
 * UI controls for intensity, smoothing, debug info, and atlas mode
 */
export default function Controls({
  intensity,
  smoothing,
  showDebug,
  yawRange,
  pitchRange,
  deadZonePercent,
  depthEnabled,
  cursorHidden,
  onIntensityChange,
  onSmoothingChange,
  onYawRangeChange,
  onPitchRangeChange,
  onDeadZoneChange,
  onDepthEnabledChange,
  onCursorHiddenChange,
  onToggleDebug,
  onReset,
  rotation,
  fps,
  // Model status
  modelStatus,
  // Atlas mode props
  atlasEnabled,
  atlasGridCoords,
  atlasError,
  atlasCached,
  onGenerateAtlas,
  onResetAtlas
}: ControlsProps) {
  return (
    <div className="controls">
      <div className="controls-panel">
        {/* Depth Effect Master Toggle */}
        <div className="control-group depth-toggle">
          <label htmlFor="depthToggle">
            <input
              id="depthToggle"
              type="checkbox"
              checked={depthEnabled}
              onChange={(e) => onDepthEnabledChange(e.target.checked)}
            />
            Enable Depth Effect
          </label>
        </div>

        {/* Cursor Visibility Toggle */}
        <div className="control-group cursor-toggle">
          <label htmlFor="cursorToggle">
            <input
              id="cursorToggle"
              type="checkbox"
              checked={!cursorHidden}
              onChange={(e) => onCursorHiddenChange(!e.target.checked)}
            />
            Show Cursor
          </label>
        </div>

        {/* Depth Effect Sliders (only visible when depth is enabled) */}
        {depthEnabled && (
          <>
            <div className="control-group">
              <label htmlFor="intensity">
                Intensity: {intensity}%
              </label>
              <input
                id="intensity"
                type="range"
                min="0"
                max="100"
                value={intensity}
                onChange={(e) => onIntensityChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="smoothing">
                Smoothing: {smoothing}%
              </label>
              <input
                id="smoothing"
                type="range"
                min="0"
                max="100"
                value={smoothing}
                onChange={(e) => onSmoothingChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="yawRange">
                Yaw range: {yawRange.toFixed(0)}°
              </label>
              <input
                id="yawRange"
                type="range"
                min="0"
                max="30"
                value={yawRange}
                onChange={(e) => onYawRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="pitchRange">
                Pitch range: {pitchRange.toFixed(0)}°
              </label>
              <input
                id="pitchRange"
                type="range"
                min="0"
                max="20"
                value={pitchRange}
                onChange={(e) => onPitchRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="deadZone">
                Dead zone: {deadZonePercent.toFixed(0)}%
              </label>
              <input
                id="deadZone"
                type="range"
                min="0"
                max="20"
                value={deadZonePercent}
                onChange={(e) => onDeadZoneChange(Number(e.target.value))}
              />
            </div>
          </>
        )}

        <div className="control-group">
          <button onClick={onToggleDebug} className={showDebug ? 'active' : ''}>
            {showDebug ? 'Hide' : 'Show'} Debug
          </button>
          <button onClick={onReset}>Reset</button>
        </div>

        {/* Atlas mode controls */}
        <div className="control-group atlas-controls">
          {!atlasEnabled && onGenerateAtlas && (
            <button onClick={onGenerateAtlas} className="atlas-generate-btn">
              Generate Atlas
            </button>
          )}

          {atlasEnabled && (
            <div className="atlas-status">
              <div className="atlas-status-info">
                <span className="atlas-status-label">
                  Atlas Active
                  {atlasCached && <span className="atlas-cached-badge" title="Atlas loaded from cache">📦 Cached</span>}
                </span>
                {atlasGridCoords && (
                  <span className="atlas-grid-coords">
                    px: {atlasGridCoords.px}, py: {atlasGridCoords.py}
                  </span>
                )}
              </div>
              {onResetAtlas && (
                <button onClick={onResetAtlas} className="atlas-reset-btn">
                  Clear Atlas
                </button>
              )}
            </div>
          )}

          {atlasError && (
            <div className="atlas-error">
              ⚠️ {atlasError}
            </div>
          )}
        </div>
      </div>

      {showDebug && (
        <div className="debug-panel">
          <div className="debug-item">
            <span className="debug-label">Yaw:</span>
            <span className="debug-value">{rotation.yaw.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">Pitch:</span>
            <span className="debug-value">{rotation.pitch.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">FPS:</span>
            <span className="debug-value">{fps}</span>
          </div>
        </div>
      )}
    </div>
  )
}


```

```typescriptreact
import './Controls.css'

interface ControlsProps {
  intensity: number
  smoothing: number
  showDebug: boolean
  yawRange: number
  pitchRange: number
  deadZonePercent: number
  depthEnabled: boolean
  cursorHidden: boolean
  onIntensityChange: (value: number) => void
  onSmoothingChange: (value: number) => void
  onYawRangeChange: (value: number) => void
  onPitchRangeChange: (value: number) => void
  onDeadZoneChange: (value: number) => void
  onDepthEnabledChange: (enabled: boolean) => void
  onCursorHiddenChange: (hidden: boolean) => void
  onToggleDebug: () => void
  onReset: () => void
  rotation: { yaw: number; pitch: number }
  fps: number
  // Model status
  modelStatus?: 'loading' | 'loaded' | 'fallback' | null
  // Atlas mode props
  atlasEnabled?: boolean
  atlasGridCoords?: { px: number; py: number } | null
  atlasError?: string | null
  atlasCached?: boolean
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
}

/**
 * UI controls for intensity, smoothing, debug info, and atlas mode
 */
export default function Controls({
  intensity,
  smoothing,
  showDebug,
  yawRange,
  pitchRange,
  deadZonePercent,
  depthEnabled,
  cursorHidden,
  onIntensityChange,
  onSmoothingChange,
  onYawRangeChange,
  onPitchRangeChange,
  onDeadZoneChange,
  onDepthEnabledChange,
  onCursorHiddenChange,
  onToggleDebug,
  onReset,
  rotation,
  fps,
  // Model status
  modelStatus,
  // Atlas mode props
  atlasEnabled,
  atlasGridCoords,
  atlasError,
  atlasCached,
  onGenerateAtlas,
  onResetAtlas
}: ControlsProps) {
  return (
    <div className="controls">
      <div className="controls-panel">
        {/* Model Status Indicator */}
        {modelStatus && (
          <div className="control-group model-status">
            <div className={`model-status-indicator model-status-${modelStatus}`}>
              {modelStatus === 'loading' && (
                <>
                  <span className="model-status-icon">⏳</span>
                  <span className="model-status-text">Loading model...</span>
                </>
              )}
              {modelStatus === 'loaded' && (
                <>
                  <span className="model-status-icon">✅</span>
                  <span className="model-status-text">Model loaded</span>
                </>
              )}
              {modelStatus === 'fallback' && (
                <>
                  <span className="model-status-icon">⚠️</span>
                  <span className="model-status-text">Using fallback depth</span>
                </>
              )}
            </div>
          </div>
        )}

        {/* Depth Effect Master Toggle */}
        <div className="control-group depth-toggle">
          <label htmlFor="depthToggle">
            <input
              id="depthToggle"
              type="checkbox"
              checked={depthEnabled}
              onChange={(e) => onDepthEnabledChange(e.target.checked)}
            />
            Enable Depth Effect
          </label>
        </div>

        {/* Cursor Visibility Toggle */}
        <div className="control-group cursor-toggle">
          <label htmlFor="cursorToggle">
            <input
              id="cursorToggle"
              type="checkbox"
              checked={!cursorHidden}
              onChange={(e) => onCursorHiddenChange(!e.target.checked)}
            />
            Show Cursor
          </label>
        </div>

        {/* Depth Effect Sliders (only visible when depth is enabled) */}
        {depthEnabled && (
          <>
            <div className="control-group">
              <label htmlFor="intensity">
                Intensity: {intensity}%
              </label>
              <input
                id="intensity"
                type="range"
                min="0"
                max="100"
                value={intensity}
                onChange={(e) => onIntensityChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="smoothing">
                Smoothing: {smoothing}%
              </label>
              <input
                id="smoothing"
                type="range"
                min="0"
                max="100"
                value={smoothing}
                onChange={(e) => onSmoothingChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="yawRange">
                Yaw range: {yawRange.toFixed(0)}°
              </label>
              <input
                id="yawRange"
                type="range"
                min="0"
                max="30"
                value={yawRange}
                onChange={(e) => onYawRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="pitchRange">
                Pitch range: {pitchRange.toFixed(0)}°
              </label>
              <input
                id="pitchRange"
                type="range"
                min="0"
                max="20"
                value={pitchRange}
                onChange={(e) => onPitchRangeChange(Number(e.target.value))}
              />
            </div>

            <div className="control-group">
              <label htmlFor="deadZone">
                Dead zone: {deadZonePercent.toFixed(0)}%
              </label>
              <input
                id="deadZone"
                type="range"
                min="0"
                max="20"
                value={deadZonePercent}
                onChange={(e) => onDeadZoneChange(Number(e.target.value))}
              />
            </div>
          </>
        )}

        <div className="control-group">
          <button onClick={onToggleDebug} className={showDebug ? 'active' : ''}>
            {showDebug ? 'Hide' : 'Show'} Debug
          </button>
          <button onClick={onReset}>Reset</button>
        </div>

        {/* Atlas mode controls */}
        <div className="control-group atlas-controls">
          {!atlasEnabled && onGenerateAtlas && (
            <button onClick={onGenerateAtlas} className="atlas-generate-btn">
              Generate Atlas
            </button>
          )}

          {atlasEnabled && (
            <div className="atlas-status">
              <div className="atlas-status-info">
                <span className="atlas-status-label">
                  Atlas Active
                  {atlasCached && <span className="atlas-cached-badge" title="Atlas loaded from cache">📦 Cached</span>}
                </span>
                {atlasGridCoords && (
                  <span className="atlas-grid-coords">
                    px: {atlasGridCoords.px}, py: {atlasGridCoords.py}
                  </span>
                )}
              </div>
              {onResetAtlas && (
                <button onClick={onResetAtlas} className="atlas-reset-btn">
                  Clear Atlas
                </button>
              )}
            </div>
          )}

          {atlasError && (
            <div className="atlas-error">
              ⚠️ {atlasError}
            </div>
          )}
        </div>
      </div>

      {showDebug && (
        <div className="debug-panel">
          <div className="debug-item">
            <span className="debug-label">Yaw:</span>
            <span className="debug-value">{rotation.yaw.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">Pitch:</span>
            <span className="debug-value">{rotation.pitch.toFixed(2)}°</span>
          </div>
          <div className="debug-item">
            <span className="debug-label">FPS:</span>
            <span className="debug-value">{fps}</span>
          </div>
        </div>
      )}
    </div>
  )
}


```


Adding CSS styles for the model status indicator:


```css
.controls {
  position: absolute;
  top: 20px;
  left: 20px;
  z-index: 100;
}

.controls-panel {
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  padding: 1rem;
  min-width: 200px;
}

.control-group {
  margin-bottom: 1rem;
}

.control-group:last-child {
  margin-bottom: 0;
}

.control-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  color: rgba(255, 255, 255, 0.9);
}

/* Checkbox inputs */
.control-group input[type="checkbox"] {
  margin-right: 8px;
  cursor: pointer;
  accent-color: #4CAF50;
}

.control-group label input[type="checkbox"] {
  margin-right: 8px;
}

.depth-toggle label,
.cursor-toggle label {
  display: flex;
  align-items: center;
  margin-bottom: 0;
  cursor: pointer;
}

/* Range inputs */
.control-group input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
  outline: none;
  -webkit-appearance: none;
}

.control-group input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: white;
  cursor: pointer;
}

.control-group input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: white;
  cursor: pointer;
  border: none;
}

.control-group button {
  margin-right: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0.5rem 1rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: white;
  cursor: pointer;
  font-size: 0.875rem;
  transition: all 0.2s ease;
}

.control-group button:hover {
  background: rgba(255, 255, 255, 0.2);
}

.control-group button.active {
  background: rgba(100, 150, 255, 0.3);
  border-color: rgba(100, 150, 255, 0.5);
}

.debug-panel {
  margin-top: 1rem;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 8px;
  padding: 0.75rem;
  font-family: 'Courier New', monospace;
  font-size: 0.75rem;
}

.debug-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.25rem;
}

.debug-item:last-child {
  margin-bottom: 0;
}

.debug-label {
  color: rgba(255, 255, 255, 0.7);
}

.debug-value {
  color: white;
  font-weight: bold;
}

/* Atlas Mode Controls */
.control-group.atlas-controls {
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  padding-top: 0.75rem;
  margin-top: 0.75rem;
}

.atlas-generate-btn {
  display: block;
  width: 100%;
  padding: 0.75rem !important;
  margin-right: 0 !important;
  background: linear-gradient(135deg, rgba(100, 200, 255, 0.3), rgba(100, 150, 255, 0.3)) !important;
  border: 1.5px solid rgba(100, 200, 255, 0.5) !important;
  color: #64c8ff !important;
  font-weight: 600;
  transition: all 0.3s ease;
}

.atlas-generate-btn:hover {
  background: linear-gradient(135deg, rgba(100, 200, 255, 0.5), rgba(100, 150, 255, 0.5)) !important;
  border-color: rgba(100, 200, 255, 0.8) !important;
  box-shadow: 0 0 10px rgba(100, 200, 255, 0.3);
}

.atlas-status {
  background: rgba(100, 200, 255, 0.1);
  border: 1px solid rgba(100, 200, 255, 0.3);
  border-radius: 4px;
  padding: 0.75rem;
  margin-bottom: 0.5rem;
}

.atlas-status-info {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.atlas-status-label {
  color: #64c8ff;
  font-weight: 600;
  font-size: 0.875rem;
}

.atlas-grid-coords {
  color: rgba(255, 255, 255, 0.7);
  font-size: 0.75rem;
  font-family: 'Courier New', monospace;
}

.atlas-reset-btn {
  display: block;
  width: 100%;
  padding: 0.5rem !important;
  margin-right: 0 !important;
  background: rgba(255, 100, 100, 0.15) !important;
  border: 1px solid rgba(255, 100, 100, 0.3) !important;
  color: rgba(255, 150, 150, 0.9) !important;
  font-size: 0.8rem;
}

.atlas-reset-btn:hover {
  background: rgba(255, 100, 100, 0.25) !important;
  border-color: rgba(255, 100, 100, 0.5) !important;
}

.atlas-error {
  background: rgba(255, 100, 100, 0.15);
  border: 1px solid rgba(255, 100, 100, 0.3);
  border-radius: 4px;
  padding: 0.75rem;
  color: rgba(255, 150, 150, 0.9);
  font-size: 0.8rem;
  word-break: break-word;
}

/* Model Status Indicator */
.control-group.model-status {
  margin-bottom: 0.75rem;
  padding-bottom: 0.75rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.model-status-indicator {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
}

.model-status-icon {
  font-size: 1rem;
  line-height: 1;
}

.model-status-text {
  color: rgba(255, 255, 255, 0.9);
}

.model-status-loading {
  background: rgba(255, 200, 100, 0.15);
  border: 1px solid rgba(255, 200, 100, 0.3);
}

.model-status-loaded {
  background: rgba(100, 255, 100, 0.15);
  border: 1px solid rgba(100, 255, 100, 0.3);
}

.model-status-fallback {
  background: rgba(255, 150, 100, 0.15);
  border: 1px solid rgba(255, 150, 100, 0.3);
}


```


Removing the unused `modelSource` variable:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState, generatedAtlas])

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


## 1. Merged MODEL_STORAGE.md into README.md

- Added a "Model Storage for Vercel Deployment" section after "Model Size Considerations"
- Included both CDN and Vercel Blob Storage options with setup instructions
- Added troubleshooting items from MODEL_STORAGE.md to the existing Troubleshooting section
- Deleted MODEL_STORAGE.md

## 2. Added Model Status Indicator

- Added `modelStatus` state in `Viewer.tsx` to track: `'loading'`, `'loaded'`, or `'fallback'`
- Updated the model loading logic to set status at appropriate points:
  - `'loading'` when starting to load the model
  - `'loaded'` when the model loads successfully
  - `'fallback'` when using the fallback depth map
- Added a visual indicator in the Controls panel showing:
  - ⏳ "Loading model..." (yellow/orange)
  - ✅ "Model loaded" (green)
  - ⚠️ "Using fallback depth" (orange/red)
- Styled the indicator to match the existing UI with color-coded backgrounds

The indicator appears at the top of the controls panel, so users can see whether the ML model loaded or if the app is using the fallback depth map.

---

**User**

I am trying the third demo image 

There is a bug.

It says it has 9/9 cached.

So when I use Ultra Test again, I would expect it tload from cache.

When hovering over the Atlas Preview, the image on the canvas swaps out



But when hovering over the canvas itself, the image doesn't swap out.

Also the image aspect ratio looks broken.

---

**Cursor**


Investigating atlas mode image swapping and aspect ratio handling. Reviewing the relevant code:



Checking how atlas mode updates the canvas texture:



Checking how `atlasState` is computed:



Fixing both issues: updating the atlas texture dependency and correcting the aspect ratio.



Fixing both issues: updating the effect dependency to use `atlasState.currentImageUrl` directly, and preserving aspect ratio when loading atlas textures.


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState.currentImageUrl, generatedAtlas]) // Use currentImageUrl directly instead of whole object

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Checking how the scene stores portrait dimensions and ensuring atlas images maintain aspect ratio. Also verifying mouse position tracking:



Adding debugging and ensuring mouse position updates trigger properly. Also checking if we need to handle texture aspect ratio differently:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  useEffect(() => {
    if (!atlasState.currentImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = atlasState.currentImageUrl

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState.currentImageUrl, generatedAtlas]) // Use currentImageUrl directly instead of whole object

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Using the existing `currentAtlasImageUrl` state instead of depending on `atlasState.currentImageUrl`:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [atlasState.currentImageUrl, generatedAtlas]) // Use currentImageUrl directly instead of whole object

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Fixing the aspect ratio issue. Atlas images may have different dimensions than the original portrait. Ensuring the mesh maintains the original portrait's aspect ratio:


```typescriptreact
        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Ensure texture maintains aspect ratio
          // The mesh is already scaled to match the original portrait aspect ratio,
          // so we just need to ensure the texture is properly configured
          // Atlas images should have the same dimensions as the original portrait
          // If they don't, they'll be stretched - but we maintain the mesh scale
          // to preserve the original portrait's aspect ratio
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
```


## Summary of Fixes

1. **Fixed image not swapping on canvas hover**: Changed the effect dependency from `[atlasState, generatedAtlas]` to `[currentAtlasImageUrl, generatedAtlas]`. The effect now uses the `currentAtlasImageUrl` state updated by the other effect, ensuring it triggers when the URL changes.

2. **Added debugging logs**: Added console logs to track mouse position updates and image URL changes.

3. **Added forced render**: Added an explicit render call after updating the texture to ensure the canvas updates immediately.

4. **Aspect ratio note**: Added comments about maintaining aspect ratio. The mesh is already scaled based on the original portrait dimensions, so atlas images should maintain the same aspect ratio. If atlas images have different dimensions, they may appear stretched, but the mesh scale preserves the original portrait's aspect ratio.

The main issue was the effect dependency not triggering properly. Using `currentAtlasImageUrl` state (which is updated when `atlasState.currentImageUrl` changes) ensures the texture loading effect runs when the cursor moves and the atlas image changes.

Test it and check the console logs to verify:
- Mouse position updates are logged
- Image URL changes are detected
- Textures are loading properly

If the aspect ratio still looks broken, the atlas images from Replicate may have different dimensions than the original portrait. In that case, we may need to adjust how the images are generated or how the mesh scale is handled.

---

**User**

After inference via replicate, the image becomes like the first image, when the original image looks different (second)

The aspect ratio gets broken, and the face is zoomed in.

---

**Cursor**


Investigating the color shift and aspect ratio issues. Checking how images are processed and displayed:



Checking how atlas textures are loaded and ensuring they match the original portrait's dimensions and color space:



Fixing both issues: preserving the original portrait dimensions and ensuring atlas images match the aspect ratio and color space:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Create new texture from URL
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              // Configure texture properties
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              
              // Maintain aspect ratio - ensure texture uses correct image dimensions
              // The mesh is already scaled to match portrait aspect ratio, so we just need
              // to ensure the texture is properly configured
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`[ATLAS] Failed to load atlas texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Draw atlas image centered and scaled to fit
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Fixing the color shift by ensuring proper color space handling and avoiding color profile loss during processing:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        const loader = new THREE.TextureLoader()
        const newTexture = await new Promise<THREE.Texture>((resolve, reject) => {
          loader.load(
            imageUrl,
            (texture) => {
              texture.flipY = true
              texture.colorSpace = THREE.SRGBColorSpace
              texture.needsUpdate = true
              resolve(texture)
            },
            undefined,
            (error) => {
              console.warn(`Failed to load preview texture: ${error}`)
              reject(error)
            }
          )
        })

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Updating the preview handler to use the same aspect ratio and color preservation logic:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    if (atlasState.currentImageUrl && atlasState.currentImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: atlasState.currentImageUrl,
        gridCoords: atlasState.gridCoords
      })
      setCurrentAtlasImageUrl(atlasState.currentImageUrl)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Fixed both issues:

## Fixes Applied

### 1. **Aspect Ratio & Zoom Issue**
- Store original portrait dimensions when the scene initializes
- When loading atlas images from Replicate, resize them to match the original portrait dimensions
- Preserve aspect ratio using letterboxing/pillarboxing (centered with black bars if needed)
- Prevents zoom/stretch when atlas images have different dimensions

### 2. **Color Shift Issue**
- Use high-quality image rendering (`imageSmoothingQuality: 'high'`)
- Process images through canvas to maintain color accuracy
- Use `CanvasTexture` instead of direct `TextureLoader` for better color preservation
- Applied the same processing to both main atlas loading and preview hover

## How It Works

When an atlas image is loaded:
1. Load the image and check its dimensions
2. Compare with the original portrait dimensions
3. Resize to match original dimensions while preserving aspect ratio
4. Center the image with black bars if needed (letterboxing/pillarboxing)
5. Create a texture from the processed canvas with proper color space settings

This ensures:
- Atlas images match the original portrait's aspect ratio (no zoom/stretch)
- Color accuracy is preserved during processing
- Consistent display whether loading from cache or generating new images

Note: If Replicate's model introduces a color cast (reddish tint), that's from the model output. This fix prevents additional color shifts from our processing pipeline.

Test it and check the console logs to see the dimension comparisons and processing details.

---

**User**

Bug: After loading the atlas, the atlas preview swaps the images on the canvas, but the main canvas is not refreshing automatically to load the right face gaze image

---

**Cursor**


Checking why canvas mouse movement isn't updating the atlas image. Reviewing the mouse tracking and atlas state updates:



Checking the effect that watches atlas state changes:



The effect depends on `atlasState.currentImageUrl`, but `atlasState` is a new object each render, so React may miss changes. Adding debugging and ensuring the effect triggers correctly:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    // Use a ref to track previous URL to avoid unnecessary updates
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Checking if the hook updates correctly. The issue may be that `useAtlasMode` doesn't update when the URL is the same. Ensuring it always sets the state:


```typescript
import { useState, useEffect, useCallback } from 'react'

/**
 * Configuration for atlas mode
 */
export interface AtlasConfig {
  min: number
  max: number
  step: number
  fallbackImage?: string
}

/**
 * State returned by useAtlasMode hook
 */
export interface AtlasState {
  currentImageUrl: string | null
  gridCoords: { px: number; py: number } | null
  isLoading: boolean
  error: string | null
}

/**
 * Hook for atlas-based gaze tracking
 * Maps cursor position to grid coordinates and returns the corresponding image URL
 *
 * @param imageMap Map of grid coordinates to image URLs (e.g., "px-15_py-15" -> imageUrl)
 * @param cursorX Current cursor X position (relative to container)
 * @param cursorY Current cursor Y position (relative to container)
 * @param containerWidth Width of the container
 * @param containerHeight Height of the container
 * @param config Atlas configuration (min, max, step, fallbackImage)
 * @returns Current image URL, grid coordinates, loading state, and error
 */
export function useAtlasMode(
  imageMap: Map<string, string> | null,
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  config: AtlasConfig
): AtlasState {
  const [currentImageUrl, setCurrentImageUrl] = useState<string | null>(null)
  const [gridCoords, setGridCoords] = useState<{ px: number; py: number } | null>(null)

  // Update image based on cursor position
  const updateImage = useCallback(() => {
    if (!imageMap || imageMap.size === 0) {
      setCurrentImageUrl(null)
      setGridCoords(null)
      return
    }

    // Log available keys in map for debugging
    if (imageMap.size > 0) {
      const keys = Array.from(imageMap.keys())
      console.log('[ATLAS-HOOK] Available keys in map:', keys.slice(0, 10), `... (${keys.length} total)`)
    }

    // Validate container dimensions to avoid NaN
    if (containerWidth <= 0 || containerHeight <= 0) {
      // Container not ready, use center coordinates as default
      const coords = { px: config.min, py: config.min }
      setGridCoords(coords)
      const key = createAtlasKey(coords.px, coords.py)
      let imageUrl = imageMap.get(key)
      if (!imageUrl && config.fallbackImage) {
        imageUrl = imageMap.get(config.fallbackImage)
      }
      if (!imageUrl) {
        imageUrl = imageMap.get('px0_py0')
      }
      if (imageUrl) {
        setCurrentImageUrl(imageUrl)
      }
      return
    }

    // Calculate grid coordinates from cursor position
    const coords = cursorToGridCoords(
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config.min,
      config.max,
      config.step
    )

    console.log('[ATLAS-HOOK] Calculated coords:', {
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config: { min: config.min, max: config.max, step: config.step },
      calculatedCoords: coords
    })

    setGridCoords(coords)

    // Create key for image lookup
    const key = createAtlasKey(coords.px, coords.py)
    console.log('[ATLAS-HOOK] Looking up key:', key, 'in map size:', imageMap.size)

    // Get image URL from map
    let imageUrl = imageMap.get(key)
    console.log('[ATLAS-HOOK] Found URL for key:', !!imageUrl)

    // Fallback to center image if not found
    if (!imageUrl && config.fallbackImage) {
      imageUrl = imageMap.get(config.fallbackImage)
    }

    // Fallback to center if fallback not specified
    if (!imageUrl) {
      imageUrl = imageMap.get('px0_py0')
    }

    // Always update the image URL, even if it's the same
    // This ensures React detects the change and triggers dependent effects
    if (imageUrl) {
      setCurrentImageUrl(imageUrl)
    } else {
      // Clear if no image found
      setCurrentImageUrl(null)
    }
  }, [imageMap, cursorX, cursorY, containerWidth, containerHeight, config])

  useEffect(() => {
    updateImage()
  }, [updateImage])

  return {
    currentImageUrl,
    gridCoords,
    isLoading: false,
    error: imageMap === null ? 'No atlas generated' : null
  }
}

/**
 * Create a key for atlas image lookup
 * Converts negative numbers to use 'm' prefix (e.g., -15 becomes m15)
 * Format: px{x}_py{y} (e.g., "px-15_py0" or "px15_pym15")
 */
export function createAtlasKey(px: number, py: number): string {
  return `px${px}_py${py}`
}

/**
 * Calculate grid coordinates from cursor position
 */
export function cursorToGridCoords(
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  min: number,
  max: number,
  step: number
): { px: number; py: number } {
  // Guard against invalid dimensions
  if (containerWidth <= 0 || containerHeight <= 0) {
    return { px: 0, py: 0 }
  }

  // Normalize cursor (0 to 1)
  const normalizedX = containerWidth > 0 ? cursorX / containerWidth : 0
  // Invert Y since screen Y increases downward but we want positive py to look up
  const normalizedY = containerHeight > 0 ? 1 - (cursorY / containerHeight) : 0

  // Map to grid coordinates
  const px = Math.round((normalizedX * (max - min) + min) / step) * step
  const py = Math.round((normalizedY * (max - min) + min) / step) * step

  // Guard against NaN and clamp to bounds
  const clampedPx = !isNaN(px) ? Math.max(min, Math.min(max, px)) : 0
  const clampedPy = !isNaN(py) ? Math.max(min, Math.min(max, py)) : 0

  return { px: clampedPx, py: clampedPy }
}

/**
 * Generate image filename from grid coordinates
 */
export function gridCoordsToFilename(
  px: number,
  py: number,
  basePath: string,
  size: number
): string {
  // Handle negative values with 'm' prefix (like face_looker)
  const pxStr = px < 0 ? `m${Math.abs(px)}` : `${px}`
  const pyStr = py < 0 ? `m${Math.abs(py)}` : `${py}`
  return `${basePath}gaze_px${pxStr}_py${pyStr}_${size}.webp`
}


```

```typescriptreact
  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] State updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas])
```


Reading the current state and trying again:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          setAtlasMousePosition({ x, y })
          atlasThrottleRef.current.lastUpdateTime = now
          // Debug: log when mouse position updates
          console.log('[ATLAS] Mouse position updated:', { x, y, width: rect.width, height: rect.height })
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    // Use a ref to track previous URL to avoid unnecessary updates
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


The hook may not update if the URL stays the same. Ensuring the effect always checks for changes, even when the URL is unchanged. Also verifying the mouse position updates are working:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) return

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    // Use a ref to track previous URL to avoid unnecessary updates
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


## Summary of Fixes

1. **Hook always updates**: Modified `useAtlasMode` to always set the image URL, even if it's the same, to ensure React detects changes.

2. **Improved mouse position updates**: Use functional state updates and only update when the position actually changes to avoid unnecessary re-renders.

3. **Added debugging**: Added console logs to track:
   - When mouse position updates
   - When the hook state changes
   - When image URLs change

4. **Effect dependencies**: The effect watching `atlasState.currentImageUrl` should trigger when the URL changes.

The flow should now be:
1. Mouse moves → `atlasMousePosition` updates
2. `useAtlasMode` hook recalculates with new mouse position
3. Hook finds the correct grid coordinates and image URL
4. `atlasState.currentImageUrl` updates
5. Effect detects the change and updates `currentAtlasImageUrl` state
6. Texture loading effect triggers and loads the new image

Test it and check the browser console. You should see logs showing:
- `[ATLAS] Mouse position updated` - when the mouse moves
- `[ATLAS-HOOK] Calculated coords` - when grid coordinates are calculated
- `[ATLAS] Hook state updated` - when the hook's image URL changes
- `[ATLAS] Image URL changed` - when the state updates
- `[ATLAS] Loading texture for URL` - when the texture starts loading

If it's still not working, the console logs will help identify where the chain breaks.

---

**User**

It is happening again, whereby after loading the atlas from cache, the hovers over the preview works, but not on the main canvas

---

**Cursor**


Investigating why canvas mouse movement isn't updating the atlas image. Checking if there's a difference in how cached vs newly generated images are handled:



Checking initial mouse position state and ensuring mouse tracking initializes when the atlas loads:



Initializing mouse position to the center when the atlas loads, and ensuring the effect triggers correctly:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl)

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    setAtlasMousePosition(prev => {
      if (prev.x === 0 && prev.y === 0) {
        console.log('[ATLAS] Initializing mouse position to center:', { centerX, centerY })
        return { x: centerX, y: centerY }
      }
      return prev
    })
  }, [generatedAtlas])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image:', centerImageUrl)
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')
```


Reading the current state and fixing the initialization:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    setAtlasMousePosition(prev => {
      if (prev.x === 0 && prev.y === 0) {
        console.log('[ATLAS] Initializing mouse position to center:', { centerX, centerY })
        return { x: centerX, y: centerY }
      }
      return prev
    })
  }, [generatedAtlas])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Ensuring the hook recalculates when the atlas loads and the mouse position initializes. Adding a force update mechanism:


```typescript
import { useState, useEffect, useCallback } from 'react'

/**
 * Configuration for atlas mode
 */
export interface AtlasConfig {
  min: number
  max: number
  step: number
  fallbackImage?: string
}

/**
 * State returned by useAtlasMode hook
 */
export interface AtlasState {
  currentImageUrl: string | null
  gridCoords: { px: number; py: number } | null
  isLoading: boolean
  error: string | null
}

/**
 * Hook for atlas-based gaze tracking
 * Maps cursor position to grid coordinates and returns the corresponding image URL
 *
 * @param imageMap Map of grid coordinates to image URLs (e.g., "px-15_py-15" -> imageUrl)
 * @param cursorX Current cursor X position (relative to container)
 * @param cursorY Current cursor Y position (relative to container)
 * @param containerWidth Width of the container
 * @param containerHeight Height of the container
 * @param config Atlas configuration (min, max, step, fallbackImage)
 * @returns Current image URL, grid coordinates, loading state, and error
 */
export function useAtlasMode(
  imageMap: Map<string, string> | null,
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  config: AtlasConfig
): AtlasState {
  const [currentImageUrl, setCurrentImageUrl] = useState<string | null>(null)
  const [gridCoords, setGridCoords] = useState<{ px: number; py: number } | null>(null)

  // Update image based on cursor position
  const updateImage = useCallback(() => {
    if (!imageMap || imageMap.size === 0) {
      setCurrentImageUrl(null)
      setGridCoords(null)
      return
    }

    // Log available keys in map for debugging (only once per map change)
    if (imageMap.size > 0) {
      const keys = Array.from(imageMap.keys())
      console.log('[ATLAS-HOOK] Updating image:', {
        cursorX,
        cursorY,
        containerWidth,
        containerHeight,
        availableKeys: keys.slice(0, 5),
        totalKeys: keys.length
      })
    }

    // Validate container dimensions to avoid NaN
    if (containerWidth <= 0 || containerHeight <= 0) {
      // Container not ready, use center coordinates as default
      const coords = { px: config.min, py: config.min }
      setGridCoords(coords)
      const key = createAtlasKey(coords.px, coords.py)
      let imageUrl = imageMap.get(key)
      if (!imageUrl && config.fallbackImage) {
        imageUrl = imageMap.get(config.fallbackImage)
      }
      if (!imageUrl) {
        imageUrl = imageMap.get('px0_py0')
      }
      if (imageUrl) {
        setCurrentImageUrl(imageUrl)
      }
      return
    }

    // Calculate grid coordinates from cursor position
    const coords = cursorToGridCoords(
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config.min,
      config.max,
      config.step
    )

    console.log('[ATLAS-HOOK] Calculated coords:', {
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config: { min: config.min, max: config.max, step: config.step },
      calculatedCoords: coords
    })

    setGridCoords(coords)

    // Create key for image lookup
    const key = createAtlasKey(coords.px, coords.py)
    console.log('[ATLAS-HOOK] Looking up key:', key, 'in map size:', imageMap.size)

    // Get image URL from map
    let imageUrl = imageMap.get(key)
    console.log('[ATLAS-HOOK] Found URL for key:', !!imageUrl)

    // Fallback to center image if not found
    if (!imageUrl && config.fallbackImage) {
      imageUrl = imageMap.get(config.fallbackImage)
    }

    // Fallback to center if fallback not specified
    if (!imageUrl) {
      imageUrl = imageMap.get('px0_py0')
    }

    // Always update the image URL, even if it's the same
    // This ensures React detects the change and triggers dependent effects
    if (imageUrl) {
      setCurrentImageUrl(imageUrl)
    } else {
      // Clear if no image found
      setCurrentImageUrl(null)
    }
  }, [imageMap, cursorX, cursorY, containerWidth, containerHeight, config])

  useEffect(() => {
    updateImage()
  }, [updateImage])

  return {
    currentImageUrl,
    gridCoords,
    isLoading: false,
    error: imageMap === null ? 'No atlas generated' : null
  }
}

/**
 * Create a key for atlas image lookup
 * Converts negative numbers to use 'm' prefix (e.g., -15 becomes m15)
 * Format: px{x}_py{y} (e.g., "px-15_py0" or "px15_pym15")
 */
export function createAtlasKey(px: number, py: number): string {
  return `px${px}_py${py}`
}

/**
 * Calculate grid coordinates from cursor position
 */
export function cursorToGridCoords(
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  min: number,
  max: number,
  step: number
): { px: number; py: number } {
  // Guard against invalid dimensions
  if (containerWidth <= 0 || containerHeight <= 0) {
    return { px: 0, py: 0 }
  }

  // Normalize cursor (0 to 1)
  const normalizedX = containerWidth > 0 ? cursorX / containerWidth : 0
  // Invert Y since screen Y increases downward but we want positive py to look up
  const normalizedY = containerHeight > 0 ? 1 - (cursorY / containerHeight) : 0

  // Map to grid coordinates
  const px = Math.round((normalizedX * (max - min) + min) / step) * step
  const py = Math.round((normalizedY * (max - min) + min) / step) * step

  // Guard against NaN and clamp to bounds
  const clampedPx = !isNaN(px) ? Math.max(min, Math.min(max, px)) : 0
  const clampedPy = !isNaN(py) ? Math.max(min, Math.min(max, py)) : 0

  return { px: clampedPx, py: clampedPy }
}

/**
 * Generate image filename from grid coordinates
 */
export function gridCoordsToFilename(
  px: number,
  py: number,
  basePath: string,
  size: number
): string {
  // Handle negative values with 'm' prefix (like face_looker)
  const pxStr = px < 0 ? `m${Math.abs(px)}` : `${px}`
  const pyStr = py < 0 ? `m${Math.abs(py)}` : `${py}`
  return `${basePath}gaze_px${pxStr}_py${pyStr}_${size}.webp`
}


```

```typescript
import { useState, useEffect, useCallback } from 'react'

/**
 * Configuration for atlas mode
 */
export interface AtlasConfig {
  min: number
  max: number
  step: number
  fallbackImage?: string
}

/**
 * State returned by useAtlasMode hook
 */
export interface AtlasState {
  currentImageUrl: string | null
  gridCoords: { px: number; py: number } | null
  isLoading: boolean
  error: string | null
}

/**
 * Hook for atlas-based gaze tracking
 * Maps cursor position to grid coordinates and returns the corresponding image URL
 *
 * @param imageMap Map of grid coordinates to image URLs (e.g., "px-15_py-15" -> imageUrl)
 * @param cursorX Current cursor X position (relative to container)
 * @param cursorY Current cursor Y position (relative to container)
 * @param containerWidth Width of the container
 * @param containerHeight Height of the container
 * @param config Atlas configuration (min, max, step, fallbackImage)
 * @returns Current image URL, grid coordinates, loading state, and error
 */
export function useAtlasMode(
  imageMap: Map<string, string> | null,
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  config: AtlasConfig
): AtlasState {
  const [currentImageUrl, setCurrentImageUrl] = useState<string | null>(null)
  const [gridCoords, setGridCoords] = useState<{ px: number; py: number } | null>(null)

  // Update image based on cursor position
  const updateImage = useCallback(() => {
    if (!imageMap || imageMap.size === 0) {
      setCurrentImageUrl(null)
      setGridCoords(null)
      return
    }

    // Log available keys in map for debugging (only once per map change)
    if (imageMap.size > 0) {
      const keys = Array.from(imageMap.keys())
      console.log('[ATLAS-HOOK] Updating image:', {
        cursorX,
        cursorY,
        containerWidth,
        containerHeight,
        availableKeys: keys.slice(0, 5),
        totalKeys: keys.length
      })
    }

    // Validate container dimensions to avoid NaN
    if (containerWidth <= 0 || containerHeight <= 0) {
      // Container not ready, use center coordinates as default
      const coords = { px: config.min, py: config.min }
      setGridCoords(coords)
      const key = createAtlasKey(coords.px, coords.py)
      let imageUrl = imageMap.get(key)
      if (!imageUrl && config.fallbackImage) {
        imageUrl = imageMap.get(config.fallbackImage)
      }
      if (!imageUrl) {
        imageUrl = imageMap.get('px0_py0')
      }
      if (imageUrl) {
        setCurrentImageUrl(imageUrl)
      }
      return
    }

    // Calculate grid coordinates from cursor position
    const coords = cursorToGridCoords(
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config.min,
      config.max,
      config.step
    )

    console.log('[ATLAS-HOOK] Calculated coords:', {
      cursorX,
      cursorY,
      containerWidth,
      containerHeight,
      config: { min: config.min, max: config.max, step: config.step },
      calculatedCoords: coords
    })

    setGridCoords(coords)

    // Create key for image lookup
    const key = createAtlasKey(coords.px, coords.py)
    console.log('[ATLAS-HOOK] Looking up key:', key, 'in map size:', imageMap.size)

    // Get image URL from map
    let imageUrl = imageMap.get(key)
    console.log('[ATLAS-HOOK] Found URL for key:', !!imageUrl)

    // Fallback to center image if not found
    if (!imageUrl && config.fallbackImage) {
      imageUrl = imageMap.get(config.fallbackImage)
    }

    // Fallback to center if fallback not specified
    if (!imageUrl) {
      imageUrl = imageMap.get('px0_py0')
    }

    // Always update the image URL, even if it's the same
    // This ensures React detects the change and triggers dependent effects
    if (imageUrl) {
      setCurrentImageUrl(imageUrl)
    } else {
      // Clear if no image found
      setCurrentImageUrl(null)
    }
  }, [imageMap, cursorX, cursorY, containerWidth, containerHeight, config])

  useEffect(() => {
    updateImage()
  }, [updateImage])

  // Force update when key dependencies change directly (in case callback doesn't trigger)
  useEffect(() => {
    if (imageMap && imageMap.size > 0) {
      updateImage()
    }
  }, [cursorX, cursorY, containerWidth, containerHeight, imageMap, updateImage])

  return {
    currentImageUrl,
    gridCoords,
    isLoading: false,
    error: imageMap === null ? 'No atlas generated' : null
  }
}

/**
 * Create a key for atlas image lookup
 * Converts negative numbers to use 'm' prefix (e.g., -15 becomes m15)
 * Format: px{x}_py{y} (e.g., "px-15_py0" or "px15_pym15")
 */
export function createAtlasKey(px: number, py: number): string {
  return `px${px}_py${py}`
}

/**
 * Calculate grid coordinates from cursor position
 */
export function cursorToGridCoords(
  cursorX: number,
  cursorY: number,
  containerWidth: number,
  containerHeight: number,
  min: number,
  max: number,
  step: number
): { px: number; py: number } {
  // Guard against invalid dimensions
  if (containerWidth <= 0 || containerHeight <= 0) {
    return { px: 0, py: 0 }
  }

  // Normalize cursor (0 to 1)
  const normalizedX = containerWidth > 0 ? cursorX / containerWidth : 0
  // Invert Y since screen Y increases downward but we want positive py to look up
  const normalizedY = containerHeight > 0 ? 1 - (cursorY / containerHeight) : 0

  // Map to grid coordinates
  const px = Math.round((normalizedX * (max - min) + min) / step) * step
  const py = Math.round((normalizedY * (max - min) + min) / step) * step

  // Guard against NaN and clamp to bounds
  const clampedPx = !isNaN(px) ? Math.max(min, Math.min(max, px)) : 0
  const clampedPy = !isNaN(py) ? Math.max(min, Math.min(max, py)) : 0

  return { px: clampedPx, py: clampedPy }
}

/**
 * Generate image filename from grid coordinates
 */
export function gridCoordsToFilename(
  px: number,
  py: number,
  basePath: string,
  size: number
): string {
  // Handle negative values with 'm' prefix (like face_looker)
  const pxStr = px < 0 ? `m${Math.abs(px)}` : `${px}`
  const pyStr = py < 0 ? `m${Math.abs(py)}` : `${py}`
  return `${basePath}gaze_px${pxStr}_py${pyStr}_${size}.webp`
}


```


Ensuring the effect triggers when the atlas first loads. Adding a mechanism to force an initial update:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    setAtlasMousePosition(prev => {
      if (prev.x === 0 && prev.y === 0 && container.clientWidth > 0 && container.clientHeight > 0) {
        console.log('[ATLAS] Initializing mouse position to center:', { centerX, centerY, containerWidth: container.clientWidth, containerHeight: container.clientHeight })
        // Use a small delay to ensure container dimensions are set
        setTimeout(() => {
          setAtlasMousePosition({ x: centerX, y: centerY })
        }, 100)
        return { x: centerX, y: centerY }
      }
      return prev
    })
  }, [generatedAtlas])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Removing the setTimeout and ensuring proper initialization:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas && atlasState.currentImageUrl) {
      console.log('[ATLAS] Hook state updated:', {
        imageUrl: atlasState.currentImageUrl.substring(0, 50) + '...',
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Verifying the mouse event handler attaches correctly when the atlas loads. Checking the effect dependencies:



The mouse event handler re-attaches when `generatedAtlas` changes, which is correct. Ensuring the hook always recalculates when dependencies change. Adding a key mechanism to force recalculation:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    // If depth is disabled, set scale to 0, otherwise use intensity value
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


## Summary of Fixes

1. **Added dual effect in `useAtlasMode` hook**: Added a second `useEffect` that directly watches `cursorX`, `cursorY`, `containerWidth`, `containerHeight`, and `imageMap` to ensure recalculation when these change, even if the callback dependency doesn't trigger.

2. **Initialize mouse position to center**: When the atlas loads, initialize the mouse position to the center of the container (instead of 0,0) so it starts with the correct image.

3. **Improved state update logic**: The effect that watches `atlasState.currentImageUrl` now handles cases where the URL is the same but needs to be ensured loaded.

4. **Enhanced debugging**: Added console logs to track:
   - When mouse position updates
   - When the hook recalculates
   - When image URLs change
   - Container dimensions and atlas state

5. **Fallback image loading**: If there's no current URL when the atlas loads, try to load the center image (`px0_py0`) as a fallback.

The flow should now be:
1. Atlas loads → mouse position initializes to center
2. Hook recalculates with center position → gets center image URL
3. Mouse moves → `atlasMousePosition` updates
4. Hook recalculates (via both the callback effect and the direct dependency effect)
5. `atlasState.currentImageUrl` updates
6. Effect detects change → updates `currentAtlasImageUrl` state
7. Texture loading effect triggers → loads new image

Test it and check the browser console. The logs should show:
- `[ATLAS] Initializing mouse position to center` when atlas loads
- `[ATLAS-HOOK] Updating image` when the hook recalculates
- `[ATLAS] Mouse position updated` when the mouse moves
- `[ATLAS] Image URL changed` when the URL updates
- `[ATLAS] Loading texture for URL` when textures load

If it's still not working, the console logs will show where the chain breaks.

---

**User**

I suspect that with the image changing post inference and then having the zoomed in face, the depth map for the original image no longer applies correctly? 

---

**Cursor**


The depth map was generated for the original portrait, but atlas images may be cropped/zoomed, so applying it misaligns the parallax. Checking how depth is applied in atlas mode and disabling depth parallax when atlas mode is active:



Disabling depth parallax when atlas mode is active, since atlas images already include gaze direction and the original depth map doesn't match the cropped/zoomed content:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, disable depth parallax because:
    // 1. Atlas images already have gaze direction built in
    // 2. The depth map was generated for the original portrait, not the atlas images
    // 3. Atlas images may be cropped/zoomed, making the depth map misaligned
    const shouldDisableDepth = !depthEnabled || !!generatedAtlas
    
    const scale = shouldDisableDepth
      ? 0
      : (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
    
    if (generatedAtlas && depthEnabled) {
      console.log('[ATLAS] Depth parallax disabled - atlas images already have gaze direction')
    }
  }, [intensity, depthEnabled, generatedAtlas])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms only if atlas mode is not active
      // Atlas images already have gaze direction, so depth parallax would conflict
      if (!generatedAtlas) {
        const rotation = cursorMapperRef.current.map(
          x,
          y,
          rect.width,
          rect.height
        )

        // Apply rotation - always set the values
        material.uniforms.yaw.value = rotation.yaw
        material.uniforms.pitch.value = rotation.pitch

        // Signal Three.js to apply the uniform changes
        material.uniformsNeedUpdate = true

        setCurrentRotation(rotation)
      } else {
        // In atlas mode, keep rotation at 0 to avoid depth parallax interference
        material.uniforms.yaw.value = 0
        material.uniforms.pitch.value = 0
        material.uniformsNeedUpdate = true
        setCurrentRotation({ yaw: 0, pitch: 0 })
      }

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, disable depth parallax because:
    // 1. Atlas images already have gaze direction built in
    // 2. The depth map was generated for the original portrait, not the atlas images
    // 3. Atlas images may be cropped/zoomed, making the depth map misaligned
    const shouldDisableDepth = !depthEnabled || !!generatedAtlas
    
    const scale = shouldDisableDepth
      ? 0
      : (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
    
    if (generatedAtlas && depthEnabled) {
      console.log('[ATLAS] Depth parallax disabled - atlas images already have gaze direction')
    }
  }, [intensity, depthEnabled, generatedAtlas])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Fixed the issue. When atlas mode is active, the depth map from the original portrait was being applied to atlas images that are cropped/zoomed, causing misalignment.

## Fixes Applied

1. **Disable depth parallax in atlas mode**: When `generatedAtlas` exists, automatically set `depthScale` to 0, disabling depth-based displacement.

2. **Disable depth rotation in atlas mode**: When atlas mode is active, set yaw and pitch to 0 to prevent depth-based rotation from interfering with atlas image swapping.

3. **Added logging**: Console log when depth is disabled due to atlas mode.

## Why This Fixes the Issue

- Atlas images already include gaze direction (AI-generated with different angles).
- The depth map was generated for the original portrait, not the atlas images.
- Atlas images may be cropped/zoomed, so the depth map doesn't align.
- Combining both effects creates visual artifacts.

Now when atlas mode is active:
- Depth parallax is disabled (`depthScale = 0`)
- Depth rotation is disabled (`yaw = 0`, `pitch = 0`)
- Only atlas image swapping happens based on cursor position
- The mesh displays the atlas images without depth distortion

This should resolve the zoomed-in face and aspect ratio issues, since the depth map is no longer applied to atlas images.

---

**User**

Can we not use a new depth map for the inferenced image?

---

**Cursor**


Checking how depth maps are generated so we can generate one for each atlas image:



Implementing depth map generation for each atlas image. Caching depth maps and updating the depth texture when the atlas image changes:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms only if atlas mode is not active
      // Atlas images already have gaze direction, so depth parallax would conflict
      if (!generatedAtlas) {
        const rotation = cursorMapperRef.current.map(
          x,
          y,
          rect.width,
          rect.height
        )

        // Apply rotation - always set the values
        material.uniforms.yaw.value = rotation.yaw
        material.uniforms.pitch.value = rotation.pitch

        // Signal Three.js to apply the uniform changes
        material.uniformsNeedUpdate = true

        setCurrentRotation(rotation)
      } else {
        // In atlas mode, keep rotation at 0 to avoid depth parallax interference
        material.uniforms.yaw.value = 0
        material.uniforms.pitch.value = 0
        material.uniformsNeedUpdate = true
        setCurrentRotation({ yaw: 0, pitch: 0 })
      }

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, disable depth parallax because:
    // 1. Atlas images already have gaze direction built in
    // 2. The depth map was generated for the original portrait, not the atlas images
    // 3. Atlas images may be cropped/zoomed, making the depth map misaligned
    const shouldDisableDepth = !depthEnabled || !!generatedAtlas
    
    const scale = shouldDisableDepth
      ? 0
      : (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
    
    if (generatedAtlas && depthEnabled) {
      console.log('[ATLAS] Depth parallax disabled - atlas images already have gaze direction')
    }
  }, [intensity, depthEnabled, generatedAtlas])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
          
          // Force render update
          if (sceneStateRef.current.renderer) {
            sceneStateRef.current.renderer.render(
              sceneStateRef.current.scene,
              sceneStateRef.current.camera
            )
          }
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Adding depth map generation for atlas images and updating the depth texture when the atlas image changes:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms only if atlas mode is not active
      // Atlas images already have gaze direction, so depth parallax would conflict
      if (!generatedAtlas) {
        const rotation = cursorMapperRef.current.map(
          x,
          y,
          rect.width,
          rect.height
        )

        // Apply rotation - always set the values
        material.uniforms.yaw.value = rotation.yaw
        material.uniforms.pitch.value = rotation.pitch

        // Signal Three.js to apply the uniform changes
        material.uniformsNeedUpdate = true

        setCurrentRotation(rotation)
      } else {
        // In atlas mode, keep rotation at 0 to avoid depth parallax interference
        material.uniforms.yaw.value = 0
        material.uniforms.pitch.value = 0
        material.uniformsNeedUpdate = true
        setCurrentRotation({ yaw: 0, pitch: 0 })
      }

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, disable depth parallax because:
    // 1. Atlas images already have gaze direction built in
    // 2. The depth map was generated for the original portrait, not the atlas images
    // 3. Atlas images may be cropped/zoomed, making the depth map misaligned
    const shouldDisableDepth = !depthEnabled || !!generatedAtlas
    
    const scale = shouldDisableDepth
      ? 0
      : (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
    
    if (generatedAtlas && depthEnabled) {
      console.log('[ATLAS] Depth parallax disabled - atlas images already have gaze direction')
    }
  }, [intensity, depthEnabled, generatedAtlas])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms only if atlas mode is not active
      // Atlas images already have gaze direction, so depth parallax would conflict
      if (!generatedAtlas) {
        const rotation = cursorMapperRef.current.map(
          x,
          y,
          rect.width,
          rect.height
        )

        // Apply rotation - always set the values
        material.uniforms.yaw.value = rotation.yaw
        material.uniforms.pitch.value = rotation.pitch

        // Signal Three.js to apply the uniform changes
        material.uniformsNeedUpdate = true

        setCurrentRotation(rotation)
      } else {
        // In atlas mode, keep rotation at 0 to avoid depth parallax interference
        material.uniforms.yaw.value = 0
        material.uniforms.pitch.value = 0
        material.uniformsNeedUpdate = true
        setCurrentRotation({ yaw: 0, pitch: 0 })
      }

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      // In atlas mode, we generate depth maps for each atlas image, so parallax can still work
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Adding cleanup for depth textures and ensuring we restore the original depth map when exiting atlas mode:



Adding cleanup to restore the original depth map when exiting atlas mode:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      // In atlas mode, we generate depth maps for each atlas image, so parallax can still work
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Restore original depth map when exiting atlas mode
  useEffect(() => {
    if (!generatedAtlas && sceneStateRef.current && depthMap) {
      // Atlas mode was disabled, restore original depth map
      console.log('[ATLAS] Restoring original depth map')
      
      // Dispose atlas depth texture
      if (atlasDepthTextureRef.current) {
        atlasDepthTextureRef.current.dispose()
        atlasDepthTextureRef.current = null
      }

      // Restore original depth texture
      if (sceneStateRef.current.material?.uniforms?.depthMap) {
        // Recreate depth texture from original depthMap ImageData
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (depthCtx) {
          depthCtx.putImageData(depthMap, 0, 0)
          const originalDepthTexture = new THREE.CanvasTexture(depthCanvas)
          originalDepthTexture.flipY = true
          originalDepthTexture.needsUpdate = true
          originalDepthTexture.colorSpace = THREE.LinearSRGBColorSpace
          
          sceneStateRef.current.material.uniforms.depthMap.value = originalDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      }
    }
  }, [generatedAtlas, depthMap])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      // Clear depth map cache when atlas is removed
      atlasDepthMapCacheRef.current.clear()
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Storing a reference to the original depth texture for proper restoration:


```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const originalDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      // In atlas mode, we generate depth maps for each atlas image, so parallax can still work
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Restore original depth map when exiting atlas mode
  useEffect(() => {
    if (!generatedAtlas && sceneStateRef.current && depthMap) {
      // Atlas mode was disabled, restore original depth map
      console.log('[ATLAS] Restoring original depth map')
      
      // Dispose atlas depth texture
      if (atlasDepthTextureRef.current) {
        atlasDepthTextureRef.current.dispose()
        atlasDepthTextureRef.current = null
      }

      // Restore original depth texture
      if (sceneStateRef.current.material?.uniforms?.depthMap) {
        // Recreate depth texture from original depthMap ImageData
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (depthCtx) {
          depthCtx.putImageData(depthMap, 0, 0)
          const originalDepthTexture = new THREE.CanvasTexture(depthCanvas)
          originalDepthTexture.flipY = true
          originalDepthTexture.needsUpdate = true
          originalDepthTexture.colorSpace = THREE.LinearSRGBColorSpace
          
          sceneStateRef.current.material.uniforms.depthMap.value = originalDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      }
    }
  }, [generatedAtlas, depthMap])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      // Clear depth map cache when atlas is removed
      atlasDepthMapCacheRef.current.clear()
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const originalDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        // Store reference to original depth texture for atlas mode restoration
        originalDepthTextureRef.current = depthTexture

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      // In atlas mode, we generate depth maps for each atlas image, so parallax can still work
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Restore original depth map when exiting atlas mode
  useEffect(() => {
    if (!generatedAtlas && sceneStateRef.current && depthMap) {
      // Atlas mode was disabled, restore original depth map
      console.log('[ATLAS] Restoring original depth map')
      
      // Dispose atlas depth texture
      if (atlasDepthTextureRef.current) {
        atlasDepthTextureRef.current.dispose()
        atlasDepthTextureRef.current = null
      }

      // Restore original depth texture
      if (sceneStateRef.current.material?.uniforms?.depthMap) {
        // Recreate depth texture from original depthMap ImageData
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (depthCtx) {
          depthCtx.putImageData(depthMap, 0, 0)
          const originalDepthTexture = new THREE.CanvasTexture(depthCanvas)
          originalDepthTexture.flipY = true
          originalDepthTexture.needsUpdate = true
          originalDepthTexture.colorSpace = THREE.LinearSRGBColorSpace
          
          sceneStateRef.current.material.uniforms.depthMap.value = originalDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      }
    }
  }, [generatedAtlas, depthMap])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      // Clear depth map cache when atlas is removed
      atlasDepthMapCacheRef.current.clear()
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```

```typescriptreact
import { useEffect, useRef, useState, useMemo } from 'react'
import * as THREE from 'three'
import { OnnxDepthRunner } from '../lib/depth/onnxRunner'
import { createScene, updateMeshSubdivisions } from '../lib/three/createScene'
import { CursorMapper } from '../lib/cursor/mapInput'
import { useAtlasMode } from '../lib/atlas/useAtlasMode'
import { CONFIG, ATLAS_CONFIG } from '../config'
import Controls from './Controls'
import AtlasPreview from './AtlasPreview'
import './Viewer.css'

interface ViewerProps {
  portraitImage: HTMLImageElement
  depthMap: ImageData | null
  generatedAtlas?: Map<string, string> | null
  atlasError?: string | null
  onDepthReady?: (depth: ImageData) => void
  onGenerateAtlas?: () => void
  onResetAtlas?: () => void
  onReset: () => void
}

/**
 * Viewer component that renders the 3D scene with depth parallax
 * Supports optional atlas mode for hybrid depth + gaze direction effects
 */
export default function Viewer({
  portraitImage,
  depthMap,
  generatedAtlas,
  atlasError,
  onDepthReady,
  onGenerateAtlas,
  onResetAtlas,
  onReset
}: ViewerProps) {

  const containerRef = useRef<HTMLDivElement>(null)
  const sceneStateRef = useRef<ReturnType<typeof createScene> | null>(null)
  const cursorMapperRef = useRef<CursorMapper>(new CursorMapper())
  const depthRunnerRef = useRef<OnnxDepthRunner | null>(null)
  const animationFrameRef = useRef<number>()
  const atlasTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthTextureRef = useRef<THREE.Texture | null>(null)
  const originalDepthTextureRef = useRef<THREE.Texture | null>(null)
  const atlasDepthMapCacheRef = useRef<Map<string, ImageData>>(new Map())
  const mousePositionRef = useRef({ x: 0, y: 0 })
  const atlasThrottleRef = useRef({ lastUpdateTime: 0 })
  const originalPortraitDimensionsRef = useRef<{ width: number; height: number } | null>(null)

  const [isProcessing, setIsProcessing] = useState(!depthMap)
  const [error, setError] = useState<string | null>(null)
  const [modelStatus, setModelStatus] = useState<'loading' | 'loaded' | 'fallback' | null>(null)
  const [intensity, setIntensity] = useState(100)
  const [smoothing, setSmoothing] = useState(50)
  const [yawRange, setYawRange] = useState<number>(CONFIG.yawRange)
  const [pitchRange, setPitchRange] = useState<number>(CONFIG.pitchRange)
  const [deadZonePercent, setDeadZonePercent] = useState(Math.round(CONFIG.deadZone * 100))
  const [showDebug, setShowDebug] = useState(false)
  const [currentRotation, setCurrentRotation] = useState({ yaw: 0, pitch: 0 })
  const [fps, setFps] = useState(0)
  const [sceneReady, setSceneReady] = useState(false)
  const [depthEnabled, setDepthEnabled] = useState(true)
  const [cursorHidden, setCursorHidden] = useState(false)

  // Atlas mode state
  const [currentAtlasImageUrl, setCurrentAtlasImageUrl] = useState<string | null>(null)
  const [currentGridCoords, setCurrentGridCoords] = useState<{ px: number; py: number } | null>(null)
  const [containerDimensions, setContainerDimensions] = useState({ width: 0, height: 0 })
  const [atlasMousePosition, setAtlasMousePosition] = useState({ x: 0, y: 0 })

  // Detect atlas config from generated atlas keys
  const atlasConfig = useMemo(() => {
    if (!generatedAtlas || generatedAtlas.size === 0) {
      return ATLAS_CONFIG
    }

    // Extract the first key to detect the grid parameters
    const firstKey = Array.from(generatedAtlas.keys())[0]

    // Parse key format: px{number}_py{number}
    const match = firstKey.match(/px(-?\d+)_py(-?\d+)/)
    if (!match) {
      console.warn('[ATLAS] Could not parse key format, using default config')
      return ATLAS_CONFIG
    }

    const values = Array.from(generatedAtlas.keys())
      .map(key => {
        const m = key.match(/px(-?\d+)_py(-?\d+)/)
        return m ? [parseInt(m[1]), parseInt(m[2])] : null
      })
      .filter(v => v !== null) as number[][]

    if (values.length === 0) {
      return ATLAS_CONFIG
    }

    // Get unique px and py values
    const pxValues = [...new Set(values.map(v => v[0]))].sort((a, b) => a - b)
    const pyValues = [...new Set(values.map(v => v[1]))].sort((a, b) => a - b)

    // Calculate step size
    const pxStep = pxValues.length > 1 ? pxValues[1] - pxValues[0] : 1
    const pyStep = pyValues.length > 1 ? pyValues[1] - pyValues[0] : 1
    const step = Math.max(pxStep, pyStep)

    const min = Math.min(...pxValues, ...pyValues)
    const max = Math.max(...pxValues, ...pyValues)

    const detectedConfig = { ...ATLAS_CONFIG, min, max, step }
    return detectedConfig
  }, [generatedAtlas])

  // Use atlas mode hook to get current image
  // This hook recalculates whenever mouse position or container dimensions change
  const atlasState = useAtlasMode(
    generatedAtlas || null,
    atlasMousePosition.x,
    atlasMousePosition.y,
    containerDimensions.width,
    containerDimensions.height,
    atlasConfig
  )

  // Debug: log when atlas state changes to help diagnose update issues
  useEffect(() => {
    if (generatedAtlas) {
      console.log('[ATLAS] Hook state:', {
        hasImageUrl: !!atlasState.currentImageUrl,
        imageUrl: atlasState.currentImageUrl ? atlasState.currentImageUrl.substring(0, 50) + '...' : null,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition,
        containerDims: containerDimensions,
        atlasSize: generatedAtlas.size
      })
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, atlasMousePosition.x, atlasMousePosition.y, containerDimensions.width, containerDimensions.height])

  // Create fallback depth map (simple radial gradient)
  const createFallbackDepth = (width: number, height: number): ImageData => {
    const imageData = new ImageData(width, height)
    const centerX = width / 2
    const centerY = height / 2
    const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2)

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const dx = x - centerX
        const dy = y - centerY
        const dist = Math.sqrt(dx ** 2 + dy ** 2)
        const normalized = Math.min(dist / maxDist, 1)
        const value = Math.floor(normalized * 255)

        const idx = (y * width + x) * 4
        imageData.data[idx] = value
        imageData.data[idx + 1] = value
        imageData.data[idx + 2] = value
        imageData.data[idx + 3] = 255
      }
    }

    return imageData
  }

  // Initialize depth inference if needed
  useEffect(() => {
    if (depthMap || !portraitImage) {
      return
    }

    let isCancelled = false

    const runDepthInference = async () => {
      try {
        setIsProcessing(true)
        setError(null)

        // Check if we should skip model loading (for testing)
        if (CONFIG.useFallbackOnly) {
          throw new Error('Using fallback depth map (debug mode)')
        }

        // Determine model path: use configured path, or try local then CDN
        let modelPath = CONFIG.modelPath
        
        if (!modelPath) {
          // Auto-detect: try local first, then CDN
          const localPath = '/models/depth-anything-v2-small.onnx'
          try {
            const response = await fetch(localPath, { method: 'HEAD' })
            if (response.ok) {
              modelPath = localPath
              console.log('[DEPTH] Using local model:', modelPath)
            } else {
              throw new Error('Local model not found')
            }
          } catch (fetchError) {
            // Local model not found, use CDN fallback
            if (CONFIG.modelCdnUrl) {
              modelPath = CONFIG.modelCdnUrl
              console.log('[DEPTH] Local model not found, using CDN:', modelPath)
            } else {
              throw new Error('Model file not found. Using fallback depth map.')
            }
          }
        } else {
          console.log('[DEPTH] Using configured model path:', modelPath)
        }

        setModelStatus('loading')

        // Check if effect was cancelled before proceeding
        if (isCancelled) return

        // Dispose existing runner if it exists
        if (depthRunnerRef.current) {
          await depthRunnerRef.current.dispose()
          depthRunnerRef.current = null
        }

        const runner = new OnnxDepthRunner()
        await runner.initialize(modelPath)

        // Check again after async operation
        if (isCancelled) {
          await runner.dispose()
          return
        }

        // Convert image to ImageData
        const canvas = document.createElement('canvas')
        canvas.width = portraitImage.width
        canvas.height = portraitImage.height
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }
        ctx.drawImage(portraitImage, 0, 0)
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)

        // Run inference
        const result = await runner.infer(imageData, true)

        // Final cancellation check before updating state
        if (isCancelled) {
          await runner.dispose()
          return
        }

        depthRunnerRef.current = runner
        setModelStatus('loaded')
        if (onDepthReady) {
          onDepthReady(result.imageData)
        }
      } catch (err) {
        if (isCancelled) return

        console.warn('Depth inference failed, using fallback:', err)
        const errorMessage = err instanceof Error ? err.message : 'Failed to generate depth map'
        setError(errorMessage)

        // Always provide fallback depth map
        setModelStatus('fallback')
        try {
          const fallbackDepth = createFallbackDepth(portraitImage.width, portraitImage.height)
          if (onDepthReady && !isCancelled) {
            onDepthReady(fallbackDepth)
          }
        } catch (fallbackError) {
          console.error('Failed to create fallback depth map:', fallbackError)
          if (!isCancelled) {
            setError('Failed to process image. Please try again.')
          }
        }
      } finally {
        if (!isCancelled) {
          setIsProcessing(false)
        }
      }
    }

    runDepthInference()

    // Cleanup function to cancel in-flight operations
    return () => {
      isCancelled = true
    }
  }, [portraitImage, depthMap, onDepthReady])

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current || !portraitImage || !depthMap) {
      return
    }

    let state: ReturnType<typeof createScene> | null = null
    let portraitTexture: THREE.Texture | null = null
    let depthTexture: THREE.Texture | null = null
    let isMounted = true

    const initScene = async () => {
      try {
        // Ensure image is loaded
        if (!portraitImage.complete || portraitImage.naturalWidth === 0) {
          await new Promise<void>((resolve, reject) => {
            const img = portraitImage!
            if (img.complete) {
              resolve()
            } else {
              img.onload = () => resolve()
              img.onerror = () => reject(new Error('Failed to load portrait image'))
            }
          })
        }

        // Create portrait texture using canvas (immediate availability)
        const portraitCanvas = document.createElement('canvas')
        portraitCanvas.width = portraitImage.width
        portraitCanvas.height = portraitImage.height
        const portraitCtx = portraitCanvas.getContext('2d')
        if (!portraitCtx) {
          throw new Error('Could not get portrait canvas context')
        }
        portraitCtx.drawImage(portraitImage, 0, 0, portraitCanvas.width, portraitCanvas.height)
        portraitTexture = new THREE.CanvasTexture(portraitCanvas)
        portraitTexture.flipY = true
        portraitTexture.needsUpdate = true
        portraitTexture.colorSpace = THREE.SRGBColorSpace

        if (!isMounted) {
          portraitTexture.dispose()
          return
        }

        // Create depth texture from ImageData (synchronous)
        const depthCanvas = document.createElement('canvas')
        depthCanvas.width = depthMap.width
        depthCanvas.height = depthMap.height
        const depthCtx = depthCanvas.getContext('2d')
        if (!depthCtx) throw new Error('Could not get depth canvas context')
        depthCtx.putImageData(depthMap, 0, 0)
        depthTexture = new THREE.CanvasTexture(depthCanvas)
        depthTexture.flipY = true
        depthTexture.needsUpdate = true
        depthTexture.colorSpace = THREE.LinearSRGBColorSpace

        // Store reference to original depth texture for atlas mode restoration
        originalDepthTextureRef.current = depthTexture

        if (!isMounted) {
          portraitTexture.dispose()
          depthTexture.dispose()
          return
        }

        // Store original portrait dimensions for atlas mode
        originalPortraitDimensionsRef.current = {
          width: portraitImage.width,
          height: portraitImage.height
        }

        // Create scene
        state = createScene(
          containerRef.current!,
          portraitTexture!,
          depthTexture!,
          {
            portraitWidth: portraitImage.width,
            portraitHeight: portraitImage.height,
            initialSubdivisions: CONFIG.meshSubdivisions
          }
        )
        sceneStateRef.current = state
        if (isMounted) {
          state.renderer.render(state.scene, state.camera)
          setSceneReady(true)
        }

      } catch (err) {
        console.error('Scene initialization error:', err)
        if (isMounted) {
          const errorMsg = err instanceof Error ? err.message : 'Failed to initialize scene'
          setError(errorMsg)
        }
      }
    }

    initScene()

    // Cleanup
    return () => {
      isMounted = false

      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }

      setSceneReady(false)

      if (state) {
        state.dispose()
      } else {
        if (portraitTexture) {
          portraitTexture.dispose()
        }
        if (depthTexture) {
          depthTexture.dispose()
        }
      }

      // Note: cleanup function cannot be async, but dispose is async
      // This is acceptable as it's cleanup - just fire and forget
      if (depthRunnerRef.current) {
        depthRunnerRef.current.dispose().catch(err =>
          console.warn('Error during cleanup dispose:', err)
        )
        depthRunnerRef.current = null
      }

      sceneStateRef.current = null
    }
  }, [portraitImage, depthMap])

  // Handle cursor input for both depth parallax and atlas mode
  useEffect(() => {
    if (!sceneReady || !containerRef.current || !sceneStateRef.current) return

    const container = containerRef.current

    const handleMove = (e: MouseEvent | TouchEvent) => {
      // Get fresh references on each event to avoid stale closures
      if (!sceneStateRef.current) return
      const material = sceneStateRef.current.material

      const rect = container.getBoundingClientRect()
      let clientX: number
      let clientY: number

      if (e instanceof MouseEvent) {
        clientX = e.clientX
        clientY = e.clientY
      } else {
        const touch = e.touches[0]
        if (!touch) return
        clientX = touch.clientX
        clientY = touch.clientY
      }

      const x = clientX - rect.left
      const y = clientY - rect.top

      // Always update mousePositionRef for depth parallax
      mousePositionRef.current = { x, y }

      // Update depth parallax uniforms
      // In atlas mode, we generate depth maps for each atlas image, so parallax can still work
      const rotation = cursorMapperRef.current.map(
        x,
        y,
        rect.width,
        rect.height
      )

      // Apply rotation - always set the values
      material.uniforms.yaw.value = rotation.yaw
      material.uniforms.pitch.value = rotation.pitch

      // Signal Three.js to apply the uniform changes
      material.uniformsNeedUpdate = true

      setCurrentRotation(rotation)

      // Update atlas coordinates if atlas mode is active
      if (generatedAtlas) {
        const now = performance.now()
        if (now - atlasThrottleRef.current.lastUpdateTime >= 33) { // ~30fps throttle
          // Always update mouse position to trigger hook recalculation
          // Use functional update to ensure React detects the change
          setAtlasMousePosition(prev => {
            // Only update if position actually changed to avoid unnecessary re-renders
            if (prev.x !== x || prev.y !== y) {
              console.log('[ATLAS] Mouse position updated:', { 
                x, 
                y, 
                prevX: prev.x, 
                prevY: prev.y,
                width: rect.width, 
                height: rect.height 
              })
              return { x, y }
            }
            return prev
          })
          atlasThrottleRef.current.lastUpdateTime = now
        }
      }
    }

    container.addEventListener('mousemove', handleMove)
    container.addEventListener('touchmove', handleMove, { passive: false })

    return () => {
      container.removeEventListener('mousemove', handleMove)
      container.removeEventListener('touchmove', handleMove)
    }
  }, [sceneReady, generatedAtlas])

  // Animation loop
  useEffect(() => {
    if (!sceneReady || !sceneStateRef.current) {
      return
    }

    const state = sceneStateRef.current
    let lastTime = performance.now()
    let frameCount = 0
    let lastFpsUpdate = performance.now()

    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)

      const now = performance.now()
      const deltaTime = now - lastTime
      lastTime = now

      // Update FPS counter
      frameCount++
      if (now - lastFpsUpdate > 1000) {
        setFps(frameCount)
        frameCount = 0
        lastFpsUpdate = now

        // Performance check: reduce subdivisions if frame time is too high
        if (deltaTime > CONFIG.frameTimeThreshold && state.mesh.geometry instanceof THREE.PlaneGeometry) {
          const currentSegments = state.mesh.geometry.parameters.widthSegments
          if (currentSegments > CONFIG.meshSubdivisionsFallback) {
            updateMeshSubdivisions(state.mesh, CONFIG.meshSubdivisionsFallback)
            console.log('Reduced mesh subdivisions for performance')
          }
        }
      }

      state.renderer.render(state.scene, state.camera)
    }

    animate()

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = undefined
      }
    }
  }, [sceneReady])

  // Update intensity (depth scale) and depth enabled
  useEffect(() => {
    if (!sceneStateRef.current) return
    
    // When atlas mode is active, we generate depth maps for each atlas image
    // So depth parallax can still work, but we may want to reduce intensity
    // since atlas images already have gaze direction built in
    const scale = depthEnabled
      ? (intensity / 100) * (CONFIG.depthScaleMax - CONFIG.depthScaleMin) + CONFIG.depthScaleMin
      : 0
      
    sceneStateRef.current.material.uniforms.depthScale.value = scale
  }, [intensity, depthEnabled])

  // Update smoothing
  useEffect(() => {
    cursorMapperRef.current.setSmoothing(smoothing)
  }, [smoothing])

  // Update yaw/pitch ranges
  useEffect(() => {
    cursorMapperRef.current.setRanges(yawRange, pitchRange)
  }, [yawRange, pitchRange])

  // Update dead zone
  useEffect(() => {
    cursorMapperRef.current.setDeadZone(deadZonePercent)
  }, [deadZonePercent])

  // Handler for previewing atlas images on hover (uses same processing as main atlas loading)
  const handleAtlasImagePreview = (imageUrl: string) => {
    if (!sceneStateRef.current || !generatedAtlas) {
      return
    }

    const loadAtlasTexture = async () => {
      try {
        // Use the same aspect ratio preservation logic as main atlas loading
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load preview image'))
          img.src = imageUrl
        })

        const originalDims = originalPortraitDimensionsRef.current
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = processedTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = processedTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        }
      } catch (err) {
        console.warn('Error loading preview texture:', err)
      }
    }

    loadAtlasTexture()
  }

  // Handle atlas mode texture updates (when atlas image changes)
  // Use currentAtlasImageUrl state which is updated by the effect below
  useEffect(() => {
    if (!currentAtlasImageUrl || !sceneStateRef.current || !generatedAtlas) {
      // If we have an atlas but no current URL, try to get the center image as fallback
      if (generatedAtlas && !currentAtlasImageUrl && sceneStateRef.current) {
        const centerImageUrl = generatedAtlas.get('px0_py0')
        if (centerImageUrl) {
          console.log('[ATLAS] No current URL, loading center image as fallback')
          setCurrentAtlasImageUrl(centerImageUrl)
        }
      }
      return
    }

    // Capture the URL to avoid TypeScript null check issues in async function
    const imageUrl = currentAtlasImageUrl
    console.log('[ATLAS] Loading texture for URL:', imageUrl.substring(0, 80) + '...')

    const loadAtlasTexture = async () => {
      try {
        // Load image first to check dimensions and ensure proper aspect ratio
        const img = new Image()
        img.crossOrigin = 'anonymous'
        
        await new Promise<void>((resolve, reject) => {
          img.onload = () => resolve()
          img.onerror = () => reject(new Error('Failed to load atlas image'))
          img.src = imageUrl
        })

        // Get original portrait dimensions
        const originalDims = originalPortraitDimensionsRef.current
        if (!originalDims) {
          console.warn('[ATLAS] Original portrait dimensions not available')
        }

        // Create canvas to resize/crop atlas image to match original portrait dimensions
        // This ensures aspect ratio and prevents zoom/stretch issues
        const canvas = document.createElement('canvas')
        const ctx = canvas.getContext('2d')
        if (!ctx) {
          throw new Error('Could not get canvas context')
        }

        if (originalDims) {
          // Resize atlas image to match original portrait dimensions while maintaining aspect ratio
          // Use letterboxing/pillarboxing to preserve aspect ratio
          const atlasAspect = img.width / img.height
          const originalAspect = originalDims.width / originalDims.height
          
          let drawWidth = originalDims.width
          let drawHeight = originalDims.height
          let drawX = 0
          let drawY = 0

          if (atlasAspect > originalAspect) {
            // Atlas is wider - fit to height, center horizontally
            drawHeight = originalDims.height
            drawWidth = drawHeight * atlasAspect
            drawX = (originalDims.width - drawWidth) / 2
          } else {
            // Atlas is taller - fit to width, center vertically
            drawWidth = originalDims.width
            drawHeight = drawWidth / atlasAspect
            drawY = (originalDims.height - drawHeight) / 2
          }

          canvas.width = originalDims.width
          canvas.height = originalDims.height
          
          // Fill with black background (or transparent)
          ctx.fillStyle = '#000000'
          ctx.fillRect(0, 0, canvas.width, canvas.height)
          
          // Use high-quality image rendering to preserve color accuracy
          ctx.imageSmoothingEnabled = true
          ctx.imageSmoothingQuality = 'high'
          
          // Draw atlas image centered and scaled to fit
          // This preserves the original image's color profile and prevents color shifts
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight)
        } else {
          // Fallback: use atlas image dimensions directly
          canvas.width = img.width
          canvas.height = img.height
          ctx.drawImage(img, 0, 0)
        }

        // Create texture from processed canvas
        const processedTexture = new THREE.CanvasTexture(canvas)
        processedTexture.flipY = true
        processedTexture.colorSpace = THREE.SRGBColorSpace
        processedTexture.needsUpdate = true

        console.log('[ATLAS] Loaded texture:', {
          originalUrl: imageUrl,
          atlasDimensions: { width: img.width, height: img.height },
          originalDimensions: originalDims,
          canvasDimensions: { width: canvas.width, height: canvas.height }
        })

        const newTexture = processedTexture

        // Dispose old texture if it exists
        if (atlasTextureRef.current) {
          atlasTextureRef.current.dispose()
        }

        // Update scene texture
        atlasTextureRef.current = newTexture
        if (sceneStateRef.current?.material?.uniforms?.map) {
          sceneStateRef.current.material.uniforms.map.value = newTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true
        } else {
          console.warn('[ATLAS] Material or uniforms not found')
        }

        // Generate depth map for this atlas image
        // Check cache first
        let atlasDepthMap = atlasDepthMapCacheRef.current.get(imageUrl)
        
        if (!atlasDepthMap && depthRunnerRef.current) {
          try {
            console.log('[ATLAS] Generating depth map for atlas image...')
            // Convert processed canvas to ImageData
            const depthCanvas = document.createElement('canvas')
            depthCanvas.width = canvas.width
            depthCanvas.height = canvas.height
            const depthCtx = depthCanvas.getContext('2d')
            if (!depthCtx) {
              throw new Error('Could not get depth canvas context')
            }
            depthCtx.drawImage(canvas, 0, 0)
            const imageData = depthCtx.getImageData(0, 0, depthCanvas.width, depthCanvas.height)

            // Run depth inference
            const depthResult = await depthRunnerRef.current.infer(imageData, true)
            atlasDepthMap = depthResult.imageData

            // Cache the depth map
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
            console.log('[ATLAS] Depth map generated and cached')
          } catch (depthError) {
            console.warn('[ATLAS] Failed to generate depth map, using fallback:', depthError)
            // Use fallback depth map
            atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
            atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
          }
        } else if (atlasDepthMap) {
          console.log('[ATLAS] Using cached depth map')
        } else {
          // No depth runner available, use fallback
          console.log('[ATLAS] No depth runner, using fallback depth map')
          atlasDepthMap = createFallbackDepth(canvas.width, canvas.height)
          atlasDepthMapCacheRef.current.set(imageUrl, atlasDepthMap)
        }

        // Update depth texture
        if (atlasDepthMap && sceneStateRef.current?.material?.uniforms?.depthMap) {
          // Create depth texture from ImageData
          const depthCanvas = document.createElement('canvas')
          depthCanvas.width = atlasDepthMap.width
          depthCanvas.height = atlasDepthMap.height
          const depthCtx = depthCanvas.getContext('2d')
          if (!depthCtx) {
            throw new Error('Could not get depth canvas context')
          }
          depthCtx.putImageData(atlasDepthMap, 0, 0)
          
          // Dispose old depth texture
          if (atlasDepthTextureRef.current) {
            atlasDepthTextureRef.current.dispose()
          }

          const newDepthTexture = new THREE.CanvasTexture(depthCanvas)
          newDepthTexture.flipY = true
          newDepthTexture.needsUpdate = true
          newDepthTexture.colorSpace = THREE.LinearSRGBColorSpace

          atlasDepthTextureRef.current = newDepthTexture
          sceneStateRef.current.material.uniforms.depthMap.value = newDepthTexture
          sceneStateRef.current.material.uniformsNeedUpdate = true

          console.log('[ATLAS] Depth texture updated')
        }

        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      } catch (err) {
        console.warn('[ATLAS] Error loading atlas texture:', err)
      }
    }

    loadAtlasTexture()

    return () => {
      // Don't dispose here - texture is reused in next update
    }
  }, [currentAtlasImageUrl, generatedAtlas]) // Use state that's updated by the effect below

  // Track container dimensions for atlas mode
  useEffect(() => {
    if (!containerRef.current) return

    const updateDimensions = () => {
      if (containerRef.current) {
        setContainerDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight
        })
      }
    }

    // Initial update
    updateDimensions()

    // Debounced window resize
    let resizeTimeout: NodeJS.Timeout | null = null
    const handleWindowResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    }

    window.addEventListener('resize', handleWindowResize)

    // ResizeObserver for container changes
    const resizeObserver = new ResizeObserver(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(updateDimensions, 100)
    })

    resizeObserver.observe(containerRef.current)

    return () => {
      window.removeEventListener('resize', handleWindowResize)
      resizeObserver.disconnect()
      if (resizeTimeout) clearTimeout(resizeTimeout)
    }
  }, []) // Empty dependency - attach once on mount and never re-attach

  // Initialize mouse position to center when atlas loads
  useEffect(() => {
    if (!generatedAtlas || !containerRef.current) return

    // Initialize mouse position to center of container
    const container = containerRef.current
    const centerX = container.clientWidth / 2
    const centerY = container.clientHeight / 2
    
    // Only initialize if mouse position is still at (0, 0) - meaning atlas just loaded
    if (container.clientWidth > 0 && container.clientHeight > 0) {
      setAtlasMousePosition(prev => {
        if (prev.x === 0 && prev.y === 0) {
          console.log('[ATLAS] Initializing mouse position to center:', { 
            centerX, 
            centerY, 
            containerWidth: container.clientWidth, 
            containerHeight: container.clientHeight 
          })
          return { x: centerX, y: centerY }
        }
        return prev
      })
    }
  }, [generatedAtlas, containerDimensions.width, containerDimensions.height])

  // Restore original depth map when exiting atlas mode
  useEffect(() => {
    if (!generatedAtlas && sceneStateRef.current && originalDepthTextureRef.current) {
      // Atlas mode was disabled, restore original depth map
      console.log('[ATLAS] Restoring original depth map')
      
      // Dispose atlas depth texture
      if (atlasDepthTextureRef.current) {
        atlasDepthTextureRef.current.dispose()
        atlasDepthTextureRef.current = null
      }

      // Restore original depth texture
      if (sceneStateRef.current.material?.uniforms?.depthMap) {
        sceneStateRef.current.material.uniforms.depthMap.value = originalDepthTextureRef.current
        sceneStateRef.current.material.uniformsNeedUpdate = true
        
        // Force render update
        if (sceneStateRef.current.renderer) {
          sceneStateRef.current.renderer.render(
            sceneStateRef.current.scene,
            sceneStateRef.current.camera
          )
        }
      }
    }
  }, [generatedAtlas])

  // Update current atlas image URL and grid coordinates when atlas state changes
  useEffect(() => {
    if (!generatedAtlas) {
      // Clear atlas state when atlas is removed
      if (currentAtlasImageUrl) {
        setCurrentAtlasImageUrl(null)
        setCurrentGridCoords(null)
      }
      // Clear depth map cache when atlas is removed
      atlasDepthMapCacheRef.current.clear()
      return
    }

    // Always update grid coordinates so they follow cursor
    setCurrentGridCoords(atlasState.gridCoords)

    // Update canvas image if URL changed - this triggers the texture loading effect above
    const newImageUrl = atlasState.currentImageUrl
    if (newImageUrl && newImageUrl !== currentAtlasImageUrl) {
      console.log('[ATLAS] Image URL changed:', {
        old: currentAtlasImageUrl,
        new: newImageUrl,
        gridCoords: atlasState.gridCoords,
        mousePos: atlasMousePosition
      })
      setCurrentAtlasImageUrl(newImageUrl)
    } else if (!newImageUrl && currentAtlasImageUrl) {
      // Clear if URL becomes null
      console.log('[ATLAS] Image URL cleared')
      setCurrentAtlasImageUrl(null)
    } else if (newImageUrl && newImageUrl === currentAtlasImageUrl) {
      // Even if URL is the same, ensure we trigger a check
      // This handles the case where atlas loads but URL hasn't changed yet
      console.log('[ATLAS] Image URL unchanged, but ensuring texture is loaded:', newImageUrl.substring(0, 50))
    }
  }, [atlasState.currentImageUrl, atlasState.gridCoords, generatedAtlas, currentAtlasImageUrl, atlasMousePosition.x, atlasMousePosition.y])

  if (isProcessing) {
    return (
      <div className="viewer-container">
        <div className="processing-overlay">
          <div className="spinner"></div>
          <p>Generating depth map...</p>
          <p className="processing-hint">This may take a few seconds</p>
        </div>
      </div>
    )
  }

  if (error && !depthMap) {
    // If we have an error but no depth map yet, show error
    // Otherwise, if we have depthMap (from fallback), show viewer
    return (
      <div className="viewer-container">
        <div className="error-overlay">
          <p>Error: {error}</p>
          <p className="error-hint">Using fallback depth map</p>
        </div>
      </div>
    )
  }

  // Show viewer if we have depthMap (either from model or fallback)
  if (depthMap) {
    return (
      <div className="viewer-container">
        {error && (
          <div className="error-banner">
            <p>⚠️ {error}</p>
          </div>
        )}
        <div ref={containerRef} className={`viewer-canvas ${cursorHidden ? 'cursor-hidden' : ''}`} />
      <Controls
          intensity={intensity}
          smoothing={smoothing}
          showDebug={showDebug}
        yawRange={yawRange}
        pitchRange={pitchRange}
        deadZonePercent={deadZonePercent}
        depthEnabled={depthEnabled}
        cursorHidden={cursorHidden}
          onIntensityChange={setIntensity}
          onSmoothingChange={setSmoothing}
        onYawRangeChange={setYawRange}
        onPitchRangeChange={setPitchRange}
        onDeadZoneChange={setDeadZonePercent}
        onDepthEnabledChange={setDepthEnabled}
        onCursorHiddenChange={setCursorHidden}
          onToggleDebug={() => setShowDebug(!showDebug)}
          onReset={onReset}
          rotation={currentRotation}
          fps={fps}
          // Model status
          modelStatus={modelStatus}
          // Atlas mode props
          atlasEnabled={!!generatedAtlas}
          atlasGridCoords={currentGridCoords}
          atlasError={atlasError}
          onGenerateAtlas={onGenerateAtlas}
          onResetAtlas={onResetAtlas}
        />
        <AtlasPreview generatedAtlas={generatedAtlas} onImageHover={handleAtlasImagePreview} />
      </div>
    )
  }

  // Should not reach here, but fallback
  return null
}


```


Implemented depth map generation for atlas images. Here's what changed:

## Changes Made

1. **Depth map generation for atlas images**: When an atlas image loads, a depth map is generated using the same ONNX model used for the original portrait.

2. **Depth map caching**: Depth maps are cached by image URL to avoid regenerating them when switching between atlas images.

3. **Dynamic depth texture updates**: When the atlas image changes, both the color texture and depth texture are updated to match the current atlas image.

4. **Original depth map restoration**: When exiting atlas mode, the original depth map is restored.

5. **Re-enabled depth parallax**: Depth parallax works in atlas mode since each atlas image has its own matching depth map.

## How It Works

- When an atlas image loads:
  1. The image is processed (resized/cropped to match original portrait dimensions)
  2. A depth map is generated from the processed image using the ONNX depth model
  3. The depth map is cached by image URL
  4. Both the color texture and depth texture are updated in the shader

- When switching atlas images:
  - If a depth map exists in cache, it's reused
  - Otherwise, a new depth map is generated

- When exiting atlas mode:
  - Atlas depth textures are disposed
  - The original depth map is restored

This ensures each atlas image has a matching depth map, so depth parallax aligns correctly with the atlas image content. The depth map is generated from the processed (resized/cropped) atlas image, so it matches the visual content being displayed.

---

**User**

Is the depth map made only for px:0 py:0, or for every image?


---

**Cursor**


Checking the code to see how depth maps are generated:



Depth maps are generated for every atlas image, not just `px0_py0`. They're created on-demand as each image is displayed.

## How It Works

1. Lazy generation: When an atlas image is displayed (e.g., `px0_py0`, `px1_py0`, `px-1_py1`), a depth map is generated for that specific image.
2. Caching: Each depth map is cached by image URL, so regenerating isn't needed when switching back to a previously shown image.
3. On-demand: Depth maps are generated only when the image is first displayed, not all at once upfront.

## Flow

- User moves cursor → `currentAtlasImageUrl` changes (e.g., from `px0_py0` to `px1_py0`)
- Effect triggers → checks cache for that URL
- If not cached → generates depth map for that image
- If cached → reuses the cached depth map
- Updates both color texture and depth texture in the shader

So if you have a 3x3 grid (9 images), you'll generate up to 9 depth maps as you move the cursor. Each atlas image gets its own depth map that matches its content.

This ensures depth parallax works correctly for each gaze direction, since each atlas image has a matching depth map.

